/* File cgen.h Created 17.05.2019 Last Modified 17.06.2020 */

/* Not a commercial goal of this laborious work is to popularize among
 * potential fans of 8-bit computers the old HI-TECH C compiler V3.09
 * (HI-TECH Software) and extend its life, outside of the CP/M environment
 * (Digital Research, Inc), for full operation in a  Unix-like operating
 * system UZI-180 without using the CP/M emulator.
 *
 * The HI-TECH C compiler V3.09 is provided free of charge for any use,
 * private or commercial, strictly as-is. No warranty or product support
 * is offered or implied including merchantability, fitness for a particular
 * purpose, or non-infringement. In no event will HI-TECH Software or its
 * corporate affiliates be liable for any direct or indirect damages.
 *
 * You may use this software for whatever you like, providing you acknowledge
 * that the copyright to this software remains with HI-TECH Software and its
 * corporate affiliates.
 *
 * All copyrights to the algorithms used, binary code, trademarks, etc.
 * belong to the legal owner - Microchip Technology Inc. and its subsidiaries.
 * Commercial use and distribution of recreated source codes without permission
 * from the copyright holderis strictly prohibited.
 *
 * The solution to this problem is to recreate the object code being moved,
 * replace the CP/M system functions (I/O, memory allocation, etc.) with
 * similar UZI-180 calls, and compile an executable file for this operating
 * system.
 */

/*
#define DEBUG
*/

/*
 *	Constant declarations
 */

#define MAXFUN	 0x20  /* Maximum limit nested function */
#define MAXBUF	   60  /* Maximum buffer size 		*/
#define MAXNAME	   40  /* Maximum file name length	*/
#define MAXERR	   30  /* Maximum number nonfatal errors*/

#define MININT -32768	/* min for int (0x8000)	*/
#define MAXINT  32767	/* max for int (0x7fff)	*/


#if 1
#define NULSTR	    0  /*  0  ""	*/
#define NOT	    1  /*  1  "!"	*/
#define NEQL	    2  /*  2  "!="	*/
#define HASHSIGN    3  /*  3  "#"	*/
#define DOLLAR	    4  /*  4  "$"	*/
#define DOLLAR_U    5  /*  5  "$U"	*/
#define MOD	    6  /*  6  "%"	*/
#define BAND	    7  /*  7  "&"	*/
#define LAND	    8  /*  8  "&&"	*/
#define GADDR	    9  /*  9  "&U"	*/
#define LPAREN	  0xA  /* 10  "("	*/
#define RPAREN	  0xB  /* 11  ")"	*/
#define MUL	  0xC  /* 12  "*"	*/
#define MUL_U	  0xD  /* 13  "*U"	*/
#define ADD	  0xE  /* 14  "+"	*/
#define INCR	  0xF  /* 15  "++"	*/
#define PLUS_U	 0x10  /* 16  "+U"	*/
#define COMMA	 0x11  /* 17  ","	*/
#define SUB	 0x12  /* 18  "-"	*/
#define DECR	 0x13  /* 19  "--"	*/
#define CONV	 0x14  /* 20  "->"	*/
#define MINUS_U	 0x15  /* 21  "-U"	*/
#define DOT	 0x16  /* 22  "."	*/
#define DOT_DOT	 0x17  /* 23  ".."	*/
#define DIV	 0x18  /* 24  "/"	*/
#define COLON	 0x19  /* 25  ":"	*/
#define COLON_U	 0x1A  /* 26  ":U"	*/
#define COLON_S	 0x1B  /* 27  ":s"	*/
#define SCOLON	 0x1C  /* 28  ";"	*/
#define T_SCOLON 0x1D  /* 29  ";;"	*/
#define LT	 0x1E  /* 30  "<"	*/
#define LSHIFT	 0x1F  /* 31  "<<"	*/
#define LEQ	 0x20  /* 32  "<="	*/
#define ASSIGN	 0x21  /* 33  "="	*/
#define ASMOD	 0x22  /* 34  "=%"	*/
#define ASAND	 0x23  /* 35  "=&"	*/
#define ASMUL	 0x24  /* 36  "=*"	*/
#define ASADD	 0x25  /* 37  "=+"	*/
#define ASSUB	 0x26  /* 38  "=-"	*/
#define ASDIV	 0x27  /* 39  "=/"	*/
#define ASLSHIFT 0x28  /* 40  "=<<"	*/
#define EQL	 0x29  /* 41  "=="	*/
#define ASRSHIFT 0x2A  /* 42  "=>>"	*/
#define ASEXOR	 0x2B  /* 43  "=^"	*/
#define ASEOR	 0x2C  /* 44  "=|"	*/
#define GT	 0x2D  /* 45  ">"	*/
#define GEQ	 0x2E  /* 46  ">="	*/
#define RSHIFT	 0x2F  /* 47  ">>"	*/
#define QUEST	 0x30  /* 48  "?"	*/
#define ATGIGN	 0x31  /* 49  "@"	*/
#define CASE	 0x32  /* 50  "[\\"	*/
#define UNKNOWN	 0x33  /* 51  "[a"	*/
#define ENUM	 0x34  /* 52  "[c"	*/
#define EXPR	 0x35  /* 53  "[e"	*/
#define INIT	 0x36  /* 54  "[i"	*/
#define STRUCT	 0x37  /* 55  "[s"	*/
#define UNION	 0x38  /* 56  "[u"	*/
#define VAR	 0x39  /* 57  "[v"	*/
#define BXOR	 0x3A  /* 58  "^"	*/
#define LBRACE	 0x3B  /* 59  "{"	*/
#define BOR	 0x3C  /* 60  "|"	*/
#define LOR	 0x3D  /* 61  "||"	*/
#define RBRACE	 0x3E  /* 62  "}"	*/
#define BNOT	 0x3F  /* 63  "~"	*/
#define RECIP	 0x40  /* 64  "RECIP"   */
#define TYPEOP	 0x41  /* 65  "TYPE"    */
#define IDOP	 0x42  /* 66  "ID"	*/
#define CONST	 0x43  /* 67  "CONST"   */
#define FCONST	 0x44  /* 68  "FCONST"  */
#define USEREG	 0x45  /* 69  "REG"     */
#define INAREG	 0x46  /* 70  "INAREG"  */
#define BFIELD   0x47  /* 71  "BITFIELD"*/
#else
enum op {
  NULSTR,	/*  0  0  ""	*/
  NOT,		/*  1  1  "!"	*/
  NEQL,		/*  2  2  "!="	*/
  HASHSIGN,	/*  3  3  "#"	*/
  DOLLAR,	/*  4  4  "$"	*/
  DOLLAR_U,	/*  5  5  "$U"	*/
  MOD,		/*  6  6  "%"	*/
  BAND,		/*  7  7  "&"	*/
  LAND,		/*  8  8  "&&"	*/
  GADDR,	/*  9  9  "&U"	*/
  LPAREN,	/* 10  A  "("	*/
  RPAREN,	/* 11  B  ")"	*/
  MUL,		/* 12  C  "*"	*/
  MUL_U,	/* 13  D  "*U"	*/
  ADD,		/* 14  E  "+"	*/
  INCR,		/* 15  F  "++"	*/
  PLUS_U,	/* 16 10  "+U"	*/
  COMMA,	/* 17 11  ","	*/
  SUB,		/* 18 12  "-"	*/
  DECR,		/* 19 13  "--"	*/
  CONV,		/* 20 14  "->"	*/
  MINUS_U,	/* 21 15  "-U"	*/
  DOT,		/* 22 16  "."	*/
  DOT_DOT,	/* 23 17  ".."	*/
  DIV,		/* 24 18  "/"	*/
  COLON,	/* 25 19  ":"	*/
  COLON_U,	/* 26 1A  ":U"	*/
  COLON_S,	/* 27 1B  ":s"	*/
  SCOLON,	/* 28 1C  ";"	*/
  T_SCOLON,	/* 29 1D  ";;"	*/
  LT,		/* 30 1E  "<"	*/
  LSHIFT,	/* 31 1F  "<<"	*/
  LEQ,		/* 32 20  "<="	*/
  ASSIGN,	/* 33 21  "="	*/
  ASMOD,	/* 34 22  "=%"	*/
  ASAND,	/* 35 23  "=&"	*/
  ASMUL,	/* 36 24  "=*"	*/
  ASADD,	/* 37 25  "=+"	*/
  ASSUB,	/* 38 26  "=-"	*/
  ASDIV,	/* 39 27  "=/"	*/
  ASLSHIFT,	/* 40 28  "=<<"	*/
  EQL,		/* 41 29  "=="	*/
  ASRSHIFT,	/* 42 2A  "=>>"	*/
  ASEXOR,	/* 43 2B  "=^"	*/
  ASEOR,	/* 44 2C  "=|"	*/
  GT,		/* 45 2D  ">"	*/
  GEQ,		/* 46 2E  ">="	*/
  RSHIFT,	/* 47 2F  ">>"	*/
  QUEST,	/* 48 30  "?"	*/
  ATGIGN,	/* 49 31  "@"	*/
  CASE,		/* 50 32  "[\\"	*/
  UNKNOWN,	/* 51 33  "[a"	*/
  ENUM,		/* 52 34  "[c"	*/
  EXPR,		/* 53 35  "[e"	*/
  INIT,		/* 54 36  "[i"	*/
  STRUCT,	/* 55 37  "[s"	*/
  UNION,	/* 56 38  "[u"	*/
  VAR,		/* 57 39  "[v"	*/
  BXOR,		/* 58 3A  "^"	*/
  LBRACE,	/* 59 3B  "{"	*/
  BOR,		/* 60 3C  "|"	*/
  LOR,		/* 61 3D  "||"	*/
  RBRACE,	/* 62 3E  "}"	*/
  BNOT,		/* 63 3F  "~"	*/
  RECIP,	/* 64 40  "RECIP"   */
  TYPEOP,	/* 65 41  "TYPE"    */
  IDOP,		/* 66 42  "ID"	    */
  CONST,	/* 67 43  "CONST"   */
  FCONST,	/* 68 44  "FCONST"  */
  USEREG,	/* 69 45  "REG"     */
  INAREG,	/* 70 46  "INAREG"  */
  BFIELD	/* 71 47  "BITFIELD"*/
};
#endif

/*
 * Classes
 */
 
#define MEMBER   0x16  /*     */
#define EDECL    0x34  /* '4' */
#define SDECL    0x37  /* '7' */
#define UDECL    0x38  /* '8' */
#define DECL9    0x39  /* '9' */
#define TDECL    0x41  /* 'A' */

/*
 *	Used macros
 */

#define LO_CHAR(a)      *((unsigned char *)&a)
#define HI_CHAR(a)      *(((unsigned char *)&a) + 1)
#define LO_WORD(a)      *((unsigned int *)&a)
#define HI_WORD(a)      *(((unsigned int *)&a) + 1)

#define bittst(var,bitno) ((var) & 1 << (bitno))
#define bitset(var,bitno) ((var) |= 1 << (bitno))
#define bitclr(var,bitno) ((var) &= ~(1 << (bitno)))

#ifndef	uchar
#define	uchar	unsigned char
#endif

#define container_of(ptr, type, member) ((type *)((char *)(ptr)-(char *)(&((type *)0)->member)))

/*
 *	Structural declarations
 */

union pw {
  int		* pi;
  char		* pc;
  struct aaa	* pst;
  int		  i;
  unsigned int	  ui;
  char		  ch[2];
  uchar		  uch[2];
};

union lw {
  long		  l;
  unsigned long   ul;
  struct aaa	* wi[2];
  struct bbb	* vi[2];
  char		* ci[2];
  char		  bc[4];
  int		* pl[2];
  unsigned long	* lp[2];
  unsigned	  ii[2];
};

struct	aaa {		/* Offset  	Used values  &  Description	*/
  uchar		a_c0;	/* +0  0	0 - 0x47			*/
  uchar		a_c1;	/* +1  1					*/
  uchar		a_c2;	/* +2  2	0, 1, 2,			*/
  uchar		a_c3;	/* +3  3					*/
  uchar		a_c4;	/* +4  4					*/
  uchar		a_c5;	/* +5  5					*/
  uchar		a_c6;	/* +6  6					*/
  struct aaa  * a_i5;	/* +7  7					*/
			/* +8  8					*/
  unsigned int  a_i6;	/* +9  9					*/
			/* +A 10					*/
  int		a_i7;	/* +B 11					*/
			/* +C 12					*/
  unsigned int  a_i8;	/* +D 13					*/
			/* +E 14					*/
  struct aaa  * a_i9;	/* +F 15					*/
			/*+10 16					*/
  int		a_i10;	/*+11 17					*/
			/*+12 18					*/
  int	      * a_i11;	/*+13 19					*/
			/*+14 20					*/
  unsigned int 	a_i12;	/*+15 21					*/
			/*+16 22					*/
  struct bbb  * a_i14;	/*+17 23					*/
			/*+18 24					*/
  union lw	a_l15;	/*+19 25					*/
			/*+1A 26					*/
			/*+1B 27					*/
			/*+1C 28					*/
};

struct	bbb {		/* Offset Member Description			*/
  char	      * b_name;	/* +0   0 s_name Pointer to Name identifier 	*/
			/* +1   1					*/
  char		b_class;/* +2	2 s_class	    0x16 - MEMBER 	*/
  			/*			    '4' -  EDECL	*/
  			/*			    '7' -  SDECL 	*/
  			/*			    '8' -  UDECL	*/
  			/*			    '9' - 		*/
  			/*			    'A' -  TYPE		*/
  char		b_c3;	/* +3	3 s_strg Bits used: 0 0000001 -		*/
  			/*		            1 0000010 -	global?	*/
  			/*		            2 0000100 -		*/
  			/*		            3 0001000 -	register?*/
  			/*		            4 0010000 -		*/
  char		b_ndpth;/* +4	4 s_ndpth Nesting depth of block	*/
  int		b_i5;	/* +5   5					*/
			/* +6   6					*/
  struct bbb *  b_next; /* +7   7					*/
			/* +8   8					*/
  unsigned	b_size; /* +9   9 s_size Type size			*/
			/* +A  10					*/
  int		b_nelem;/* +B  11 s_nelem				*/
			/* +C  12					*/
  unsigned	b_refl;	/* +D  13 s_refl				*/
			/* +E  14					*/
  struct bbb  * b_type;	/* +F  15 s_type				*/
			/* +10 16					*/
  int		b_i11;	/* +11 17 s_alig Type alig  size stack frame	*/
			/* +12 18					*/
  int	      * b_memb;	/* +13 19 s_memb Struct store			*/
			/* +14 20					*/
  char		b_c13;  /* +15 21	 type flag 0, 1, 2, 3, 4, 5,	*/
};

struct zzz {
  char		c_0;
  char		c_1;
  char		c_2;
  char		c_3;
  char		c_4;
  char		c_5;
  char 	      * p_6;
  char	      * p_8;
};

struct ptr {
  struct ptr * next_ptr;
};

struct header1 {
  uchar size;
  struct ptr next;
};

struct header2 {
  unsigned size;
  char aaa; 
  struct ptr next;
};

struct type {
  char	* t_str;
  int	  t_size;
  int	  t_alig;
  char	  t_flag;
};

/*
 *	Descriptions of variables and arrays
 *
 * Declarations are located in sequence of being in
 * original binary image of CGEN.COM
 *					Purpose				Where it is used
 * ===== Start bss section ======= */
extern char         buffer[MAXBUF];					/* sub_306  */
extern int          lineno;						/* sub_306, sub_6AD0, sub_6B55*/
extern char         progname[MAXNAME];	/*			   */	/* sub_306  */
extern char         byte_AE0C;		/* First call ncsv	   */	/* sub_2BD0 */
extern int          cursect; 		/*  Current section	   */ 	/* selpsect  */
extern int          word_AE0F;		/*			   */ 	/* sub_174C */
extern struct bbb * word_AE11;		/* "l" - long		   */ 	/* sub_1680, sub_415E, sub_43EF */
extern int          array_AE13[MAXFUN]; /*			   */ 	/* sub_406,  sub_17E0, sub_5CF5 */
extern struct bbb * word_AE53;		/* "uc" - unsigned char	   */
extern unsigned     nstdpth;		/* Current nesting depth   */
extern int          array_AE57[MAXFUN]; /*			   */
extern int          array_AE97[MAXFUN]; /*			   */
extern struct bbb * word_AED7;		/* "d" - double 	   */
extern struct bbb * word_AED9;		/* "c" - char 		   */
extern struct bbb * array_AEDB[MAXFUN]; /*			   */
extern struct bbb * word_AF1B;		/* "b"			   */
extern struct bbb * word_AF1D;		/* "x"			   */
extern struct bbb * hashtab[101];	/* hash table (array_AF1F) */
extern struct bbb * word_AFE9;		/* "v" - variable  	   */
extern int          lvlidx;		/* Level nested function   */	/* sub_406, sub_1680 */

extern int          word_AFED;						/* sub_1F4B */
extern char       * word_AFEF;						/* sub_1F4B */
extern char       * word_AFF1;						/* sub_1F4B */
extern char         byte_AFF3;						/* sub_1F4B */
extern int          word_AFF4;						/* sub_1F4B */
extern int          word_AFF6;						/* sub_1F4B */

extern int          word_AFF8;						/* sub_2D09, sub_3564 */
extern char         byte_AFFA;						/* sub_283E, sub_2B79 */
extern int          word_AFFB;						/* sub_2D09, sub_35E6 */
extern struct aaa * array_AFFD[0x14];					/* sub_3CDF, sub_3DC9 */
extern void	  * word_B011;						/* sub_36E0, sub_3712, sub_374C */
extern char         byte_B013;						/* sub_36E0, sub_3712, ... */
extern uchar        byte_B014;						/* sub_3CDF, sub_3DC9 */
extern char       * word_B015;	/* msgptr  Pointer str printf       */
extern int          word_B017;						/* sub_406, sub_6D1, sub_283E, sub_2BD0, sub_61AA */
extern char         wflag;		/* Warning messages	    */	/* main, sub_6AD0 */
extern char         pflag;		/* Not used		    */	/* main */
extern char         hflag;		/* Not used		    */	/* main */
extern int          errcnt;		/* Number of errors	    */	/* main, uerror */
extern char         bflag;		/* Not used		    */	/* main */
extern char       * beg_sbrk;		/* Current highest memory   */	/* main */
extern char         eflag;		/* Not used		    */	/* main */
extern char         rflag;		/*			    */	/* main, sub_61AA */

extern struct header1 word_B023; 					/* sub_6D61, cmalloc, sub_7028 */

#if 0
extern int          word_B026;						/* sprintf */
extern int          word_B028;						/* sprintf */
extern char         byte_B02E;						/* pnum, doprnt */
extern int          word_B02F;						/* pputc */
extern char         byte_B031;						/* pnum, doprnt */
extern char         buf_B032[512];					/* pnum, doprnt */
extern int          __argc_;						/* startup */
extern int          memtop;
#endif						/* brk, sbrk */
/* ===== End of bss section ======= */


/* ===== Start data section ======= */

extern char       * array_805F[];					/*+sub_2D09 */
extern struct zzz   array_80EF[];					/* sub_1F4B, sub_283E, sub_2D09, sub_3564 */
extern int          array_987D[];					/*+sub_13D  */
extern char         array_990D[];					/*+sub_13D  */
extern int          array_9BD4[];					/*+sub_13D  */
extern int          array_A162[];					/*+sub_1F4B */
extern char       * tnames[];						/*+sub_1B2  */
				
extern char         byte_A46A;		/* Initial value middle  */	/*+sub_1B2  */
					/* element used in binary search */
extern char         array_A542[];					/*+sub_153A */
extern char       * off_A592[];						/*+selpsect  */
extern int          dopetab[72];					/*+sub_1F4B, sub_2B8A, sub_2D09, sub_35E6, sub_377A, ... */
extern char         array_A94A[];					/*+sub_1F4B */
extern int          array_AAE8[];					/*+sub_406,  sub_1F4B, sub_283E, sub_61AA, sub_63B8, sub_6589, sub_66BC */
extern uchar        array_AB24[];					/*+sub_283E, sub_2D09, sub_665B */
extern uchar        array_AB54[];					/*+sub_63B8, sub_6589 */


extern struct type  vars[14];  						/* sub_1680 */
extern char       * off_AACA[];

/*
 * Added dummy variable "empty" to eliminate sub_5CF5 function
 * call with different number of parameters
 */

/*
extern int	    empty;
extern FILE	   *f_out, *f_in;
*/

/* ===== End of data section ======= */

/*
 * Function prototype
 *
 * Missing Hi-Tech C header files
 */

/*
long	     atol(char *str);
*/
int	     atoi(char *);
void	     blkclr(char *, unsigned short size);
void	   * sbrk(int);
/****************************************************************
 * Prototype functions are located in sequence of being in
 * original binary image of CGEN.COM
 *
 * ok++ - Full binary compatibility with code in original file;
 * ok+  - Code generated during compilation differs slightly,
 *        but is logically correct;
 * ok   - C source code was compiled successfully, but not verified.
 ****************************************************************/
/* lex.c ----------------------------------------------------------------------*/
int	     sub_13D(int, int);				/*.ok+  sub_13D.c	*/
char         sub_1B2(char *);				/* ok++ sub_1B2.c	*/
struct bbb **gethashptr(char *);	/*sub_21F*/	/* ok++			*/
struct bbb * sub_265(char *);				/* ok++			*/
char 	   * sub_306(void);				/*.ok+  sub_306.c	*/
void         sub_406(void);				/*.ok+  sub_406.c	*/
struct bbb * sub_627(char *, unsigned *);		/* ok++ 		*/
void	     sub_6C8(void);				/* ok++ 		*/
void	     sub_6D1(void);				/*.ok+  sub_6D1.c	*/
void	     sub_76F(int);				/* ok++ sub_76F.c	*/
void         sub_793(void);				/* ok++ 		*/
/* code.c ----------------------------------------------------------------------*/
int	     sub_808(struct bbb *, struct aaa *); 	/*.ok+  sub_808.c	*/
void	     sub_B19(void);				/* ok++ sub_B19.c	*/
void	     sub_B96(int);				/* ok++ 		*/
void         sub_BCC(int, int);				/* ok++ 		*/
void         sub_BEE(int, int);				/* ok++ 		*/
void         sub_C36(struct bbb *);			/* ok++ 		*/
void	     sub_C57(struct bbb *);			/* ok++ 		*/
void	     sub_CAB(struct bbb *);			/* ok++ 		*/
void	     sub_CDF(int);				/* ok++ 		*/
void	     selpsect(int);		/*sub_D37*/	/* ok++ 		*/
void	     sub_D66(int *, int *, int);		/* ok++ 		*/
void	     sub_E43(void);				/* ok++ 		*/
void	     sub_1420(int);				/* ok++ 		*/
void	     sub_143F(uchar);				/* ok++ 		*/
void	     sub_1489(uchar);				/* ok++ 		*/
void	     sub_14D3(struct bbb *);			/* ok++ 		*/
char	     sub_14F3(struct aaa *);			/* ok++ 		*/
void	     sub_153A(struct aaa *);			/* ok++ 		*/
void	     sub_155D(char *, int);			/* ok++ 		*/
void	     sub_15D3(int);				/* ok++ 		*/
void	     sub_15E7(int);				/* ok++ 		*/
void	     sub_15FB(struct bbb *, int, int);		/* ok++ 		*/
int	     sub_1659(int, int);			/* ok++ sub_1659.c	*/
void	     sub_1680(void);				/* ok++ sub_1680.c	*/
int	     sub_174C(void);				/* ok++ 		*/
struct bbb * sub_1754(char *, int);			/* ok++ 		*/
/* sym.c -----------------------------------------------------------------------*/
void	     sub_17E0(void);				/*.ok+  sub_17E0.c	*/
void         sub_19C1(int);				/* ok++ sub_19C1.c	*/

void         sub_1B0C(void);	      /* missing pop bc	   ok+			*/
int	     sub_1C6D(int, int);			/* ok++ sub_1C6D.c	*/
int	     sub_1C8E(struct bbb *);			/* ok++ sub_1C8E.c	*/
int	     sub_1CC4(struct bbb *);			/* ok++ 		*/
void	     sub_1CEF(struct bbb *);			/* ok++ 		*/
void	     sub_1EDF(void);				/* ok++ 		*/
int	     sub_1F4B(struct aaa *,int,int,int,int *);	/*.ok+  optim: out of memory */
int          sub_283E(struct aaa *, int);		/*.ok+  sub_283E.c	*/
int          sub_2B2A(struct aaa *);			/*.ok+  sub_2B2A.c	*/
uchar	     sub_2B79(struct aaa *);			/* ok+  sub_2B79.c	*/
/* cgen.c ----------------------------------------------------------------------*/
void	     sub_2BD0(struct aaa *);			/* ok++			*/
long	     sub_2C5E(struct aaa *, long);		/*.ok+  sub_2C5E.c	*/
void	     sub_2CE0(struct aaa *, long);		/* ok++ sub_2CE0.c	*/
void	     sub_2D09(struct aaa *, char *, int);	/*.ok   optim: out of memory */
void	     sub_3564(struct aaa *);			/*.ok+  sub_3564.c	*/
void         sub_35E6(struct aaa *);			/*.ok+  		*/
void	     sub_36E0(struct aaa *);			/* ok++ 		*/
struct aaa * sub_3712(void);				/* ok++ 		*/
char	     sub_374C(void);				/* ok++ 		*/
struct aaa * sub_377A(struct aaa *);			/* ok++ 		*/
void	     sub_37ED(struct aaa *);			/* ok++ sub_37ED.c	*/
void	     sub_385B(struct aaa *);			/* ok++ sub_385B.c	*/
int	     sub_387A(struct aaa *);			/* ok++ 		*/
int	     sub_38CA(struct aaa *, int);		/* ok++ 		*/
int	     sub_393C(struct aaa *);			/* ok++ 		*/
int	     sub_3952(struct aaa *);			/* ok++ 		*/
int	     sub_3968(struct aaa *);			/* ok++ 		*/
unsigned     nodesize(struct aaa *);	/*sub_3993*/	/* ok++ 		*/
struct aaa * sub_39CA(struct aaa *);			/* ok++ 		*/
void	     sub_3A79(struct aaa *, struct aaa *);	/*.ok+  sub_3A79.c	*/
void	     sub_3B65(unsigned long *, long, int);	/* ok++ sub_3B65.c	*/
void	     sub_3BC6(long *, long, int);		/*.ok+  sub_3BC6.c	*/
struct aaa * sub_3CDF(struct aaa *);			/* ok++ sub_3CDF.c	*/
/* tree.c ----------------------------------------------------------------------*/
void	     sub_3DC9(struct aaa *);			/* ok++			*/
struct aaa * sub_3EAA(struct aaa *);			/*.ok+  sub_3EAA.c	*/
struct aaa * sub_415E(long);				/* ok++ sub_415E.c	*/
struct aaa * sub_4192(void);				/*.ok+  sub_4192.c	*/
struct aaa * sub_43EF(int, struct aaa *, struct aaa *); /*.ok+  sub_43EF.c	*/
uchar	     sub_46F7(long);				/* ok++ sub_46F7.c	*/
void	     sub_475C(struct aaa *);			/* ok++ sub_475C.c	*/
char	     sub_47B2(struct aaa *, int);		/*.ok+  sub_47B2.c	*/
/*
int	     sub_4B89(struct aaa *);			   ok+    
*/
uchar	     sub_4B89(struct aaa *);			/*.ok+  sub_4B89.c	*/
int	     sub_4BE5(struct aaa *);			/* ok++ sub_4BE5.c	*/
int	     sub_4C12(struct aaa *);			/* ok++ 		*/
char	     sub_4C6D(struct aaa *);			/*.ok+  sub_4C6D.c	*/
struct aaa * sub_4C8B(struct aaa *);			/* ok++ sub_4C8B.c	*/
struct aaa * sub_4DA3(struct aaa *);			/* ok++ 		*/
struct aaa * sub_4E8D(struct aaa *);			/* ok++ 		*/
struct aaa * sub_4FA8(struct aaa *);			/* ok++ 		*/
struct aaa * sub_4FCE(struct aaa *);			/*.ok+  sub_4FCE.c	*/
struct aaa * sub_508A(struct aaa *);			/* ok++ sub_508A.c	*/
struct aaa * sub_53EE(struct aaa *);			/* ok++ 		*/
/* local.c ---------------------------------------------------------------------*/
struct aaa * sub_54B6(struct aaa *); 			/*.ok   optim: out of memory */
void         sub_5CF5(struct bbb *, int);		/*.ok+  sub_5CF5.c	*/
struct aaa * sub_5DF6(struct aaa *);			/* ok++ sub_5DF6.c	*/
struct aaa * sub_5F52(struct aaa *);			/* ok++ sub_5F52.c	*/
struct aaa * sub_600E(struct aaa *);			/* ok++ sub_600E.c	*/
int	     sub_605E(int);				/*.ok+  sub_605E.c	*/
char	     sub_60A8(struct aaa *, struct aaa *);	/*.ok+  sub_60A8.c	*/
int	     sub_61AA(struct bbb *, int);		/* ok++ sub_61AA.c	*/
int	     sub_6246(struct aaa *, struct aaa *);	/* ok++ 		*/
char	     sub_628F(struct aaa *, struct aaa *);	/* ok++ 		*/
char	     sub_62BE(struct aaa *, struct aaa *);	/* ok++ 		*/
char	     sub_63B8(int, int, int);			/*.ok+  sub_63B8.c	*/
uchar	     sub_6589(int, int);			/*.ok+  sub_6589.c	*/
unsigned     sub_665B(unsigned, char);			/* ok++ 		*/
int	     sub_66BC(int, int, int, char *);		/* ok++ 		*/
/* main.c  ---------------------------------------------------------------------*/
/* int	     main(int, char **);		*/	/* ok++ 		*/

/*
 * To comply with C standard functions are replaced with
 * similar ones with a variable number of parameters
 */
/*void	     faterror(char * fmt, ...);*/	/*sub_6AA2*/	/* ok   sub_6AA2.c	*/
/*void	     warning(char * fmt, ...);*/	/*sub_6AD0*/	/* ok   		*/
/*void	     uerror(char * p1);*/		/*sub_6B1D*/	/* ok++ sub_6B1D.c	*/
/*
 * sub_6B55 excluded because it is unnecessary
 *
void	     sub_6B55(char *, int, char *);
*/
void	   * allocmem(unsigned int);	/*sub_6B9B*/	/* ok++ sub_6B9B.c	*/

/* int	     fprintf(FILE *, char *, int);	*/

int	     sub_6BF5(char *, char *, FILE *);

void 	   * sub_6D1C(char *, int);			/* ok++ sub_6D1C.c	*/
int	     sub_6D61(void);				/* ok++ 		*/
void 	   * cmalloc(unsigned);				/* ok++ 		*/
void	     sub_7028(struct ptr *);			/* ok++ 		*/

int	     sub_708D(char *, int);					/* printf */

int	     getchar(void);
int	     putchar(int);

/*
 * The following declarations may be required to recreate from a binary image
 */
char	     sub_70CB(char);						/* toupper */

/*char	     sub_70F8(struct fcb *, char *);	*/	/* ok++ */	/* def_fcb */

int	     sub_7247(char *, char *, int);				/* sprintf */

int	     sub_7288(int);						/* pputc   */
int	     sub_7325(FILE *, char *, int *);				/* doprnt  */
/* int	     fgetc(FILE *); */
int	     sub_770B(FILE *);						/* filbuf  */
char	     sub_77F5();						/* Test ^c */
/*	     exit(int); */
int	     sub_7855(FILE *);						/* fclose  */
int	     sub_78F0(FILE *);						/* fflush  */

/* End file cgen.h */

/*
 * Debug function declarations
 */
#ifdef DEBUG1
void pr_st_a(struct aaa * st);
void pr_st_b(struct bbb * st);
#endif



/*
 * File 1.c Created 17.05.2019 Last Modified 03.02.2021
 */

#include "stdio.h"
#include "cgen.h"

#define	offsetof(ty, mem)	((int)&(((ty *)0)->mem))

/* ===== start bss section ======= */
char         buffer[MAXBUF];					/* sub_306 */
int          lineno;						/* sub_306, sub_6AD0, sub_6B55*/
char         progname[MAXNAME];					/* sub_306 */
char         byte_AE0C;		/* First call ncsv	   */	/* sub_2BD0 */
int          cursect;		/* Current section	   */ 	/* sub_D37  */
int          word_AE0F;		/*			   */ 	/* sub_174C */
struct bbb * word_AE11;		/* "l" - long		   */ 	/* sub_1680, sub_415E, sub_43EF */
int          array_AE13[MAXFUN];/*			   */ 	/* sub_406,  sub_17E0, sub_5CF5 */
struct bbb * word_AE53;		/* "uc" - unsigned char	   */
unsigned     nstdpth;		/* Current nesting depth   */
int          array_AE57[MAXFUN];/*			   */
int          array_AE97[MAXFUN];/*			   */
struct bbb * word_AED7;		/* "d" - double 	   */
struct bbb * word_AED9;		/* "c" - char 		   */
struct bbb * array_AEDB[MAXFUN];/*			   */
struct bbb * word_AF1B;		/* "b"			   */
struct bbb * word_AF1D;		/* "x"			   */
struct bbb * hashtab[101];	/* hash table (array_AF1F) */
struct bbb * word_AFE9;		/* "v" - variable  	   */
int          lvlidx;		/* Level nested function   */	/* sub_406, sub_1680 */

int          word_AFED;						/* sub_1F4B */
char       * word_AFEF;						/* sub_1F4B */
char       * word_AFF1;						/* sub_1F4B */
char         byte_AFF3;						/* sub_1F4B */
int          word_AFF4;						/* sub_1F4B */
int          word_AFF6;						/* sub_1F4B */

int          word_AFF8;						/* sub_2D09, sub_3564 */
char         byte_AFFA;						/* sub_283E, sub_2B79 */
int          word_AFFB;						/* sub_2D09, sub_35E6 */
struct aaa * array_AFFD[0x14];					/* sub_3CDF, sub_3DC9 */
void	   * word_B011;						/* sub_36E0, sub_3712, sub_374C */
char         byte_B013;						/* sub_36E0, sub_3712, ... */
uchar        byte_B014;						/* sub_3CDF, sub_3DC9 */
char       * word_B015;		/* Pointer for printf      */
int          word_B017;						/* sub_406, sub_6D1, sub_283E, sub_2BD0, sub_61AA */
char         wflag;		/* Warning messages	   */	/* main, sub_6AD0 */
char         pflag;		/* Not used		   */	/* main */
char         hflag;		/* Not used		   */	/* main */
int          errcnt;		/* Number of errors	   */	/* main, sub_6B1D */
char         bflag;		/* Not used		   */	/* main */
char       * beg_sbrk;		/* Current highest memory  */	/* main */
char         eflag;		/* Not used		   */	/* main */
char         rflag;		/* Not used		   */	/* main, sub_61AA */

struct header1 word_B023; 					/* sub_6D61, cmalloc, sub_7028 */

char 	 ** word_B024;

#if 0
int          word_B026;		/* sprintf */
int          word_B028;		/* sprintf */
char         byte_B02E;		/* pnum, doprint */
int          word_B02F;		/* pputc */
char         byte_B031;		/* pnum, doprint */
char         buf_B032[512];	/* pnum, doprint */
int          __argc_;		/* startup */
int          memtop;		/* brk, sbrk */
#endif
/* ===== End of bss section ======= */

/*
 *	Variables for new functions for working with files (from the standard library) 
 */
FILE   *f_inp;
FILE   *f_out;

/*
 * Added dummy variable "empty" to eliminate sub_5CF5 function
 * call with different number of parameters
 */

int     empty;

/* End file 1.c */


/*
 * File 2.c Created 17.05.2019 Last Modified 01.04.2020
 */

extern char
  p_8ADB[], p_8B33[], p_8B34[], p_8B88[], p_8B8C[], p_8BB7[],
  p_8BE2[], p_8C23[], p_8C25[], p_8C67[], p_8CA1[], p_8CD7[],
  p_8D09[], p_8D0B[], p_8D3C[], p_8D3E[], p_8D70[], p_8D9E[],
  p_8DA1[], p_8DD0[], p_8DD2[], p_8E03[], p_8E34[], p_8E63[],
  p_8E90[], p_8EBB[], p_8EE5[], p_8F0D[], p_8F35[], p_8F5D[],
  p_8F82[], p_8FA5[], p_8FC4[], p_8FC8[], p_8FEA[], p_900C[],
  p_902D[], p_904D[], p_906D[], p_9087[], p_908C[], p_90A7[],
  p_90AB[], p_90CA[], p_90E9[], p_9107[], p_9125[], p_9143[],
  p_9160[], p_917D[], p_9199[], p_91B5[], p_91CE[], p_91D1[],
  p_91E9[], p_91ED[], p_9207[], p_9221[], p_923B[], p_9255[],
  p_926F[], p_9289[], p_92A3[], p_92BD[], p_92D7[], p_92F1[],
  p_930A[], p_9323[], p_933B[], p_9353[], p_936B[], p_9380[],
  p_9383[], p_9390[], p_939B[], p_93B3[], p_93CB[], p_93E2[],
  p_93F9[], p_940F[], p_9425[], p_943B[], p_9451[], p_9466[],
  p_947B[], p_9490[], p_94A4[], p_94B4[], p_94B6[], p_94C8[],
  p_94DA[], p_94EB[], p_94FC[], p_950D[], p_951E[], p_952F[],
  p_953F[], p_954F[], p_955F[], p_956B[], p_956E[], p_957D[],
  p_958C[], p_9597[], p_959B[], p_95AA[], p_95B9[], p_95C8[],
  p_95D6[], p_95E4[], p_95F2[], p_9600[], p_9609[], p_960D[],
  p_961A[], p_9627[], p_9634[], p_9641[], p_964E[], p_965B[],
  p_9668[], p_9675[], p_9682[], p_968E[], p_9699[], p_96A4[],
  p_96AF[], p_96B5[], p_96BA[], p_96C5[], p_96D0[], p_96DA[],
  p_96E4[], p_96EE[], p_96F8[], p_9702[], p_970C[], p_9712[],
  p_9716[], p_9720[], p_9729[], p_9732[], p_973B[], p_9744[],
  p_974D[], p_9756[], p_975E[], p_9766[], p_976B[], p_976E[],
  p_9776[], p_977E[], p_9786[], p_978E[], p_9796[], p_979E[],
  p_97A6[], p_97AD[], p_97B4[], p_97BB[], p_97C2[], p_97C9[],
  p_97D0[], p_97D7[], p_97DE[], p_97E5[], p_97EB[], p_97F1[],
  p_97F7[], p_97FD[], p_9802[], p_9807[], p_980C[], p_9811[],
  p_9816[], p_981B[], p_9820[], p_9824[], p_9828[], p_982C[],
  p_9830[], p_9834[], p_9838[], p_983C[], p_9840[], p_9844[],
  p_9848[], p_984C[], p_9850[], p_9851[], p_9854[], p_9858[],
  p_985C[], p_9860[], p_9864[], p_9867[], p_986A[], p_986B[],
  p_986D[], p_9870[], p_9873[], p_9876[], p_9879[], p_987B[];

char * array_805F[] = {
  0,		/*  0 		*/	
  0,		/*  1 		*/	
  p_986A, 	/*  2 "nz"	*/	
  0,		/*  3 		*/	
  0,		/*  4 		*/	
  0,		/*  5 		*/	
  p_983C,	/*  6 "mod"	*/	
  p_9838,	/*  7 "and"	*/	
  0,		/*  8 		*/	
  0,		/*  9 		*/	
  0,		/* 10 		*/	
  0,		/* 11 		*/	
  p_9834,	/* 12 "mul"	*/	
  0,		/* 13 		*/	
  p_9828,	/* 14 "add"	*/	
  p_9824,	/* 15 "inc"	*/	
  0,		/* 16 		*/	
  0,		/* 17 		*/	
  p_9820,	/* 18 "sub"	*/	
  p_9858,	/* 19 "dec"	*/	
  0,		/* 20 		*/	
  p_94B4,	/* 21 "0"	*/	
  0,		/* 22 		*/	
  0,		/* 23 		*/	
  p_9854,	/* 24 "div"	*/	
  0,		/* 25 		*/	
  0,		/* 26 		*/	
  0,		/* 27 		*/	
  0,		/* 28 		*/	
  0,		/* 29 		*/	
  p_9876,	/* 30 "lt"	*/	
  p_8DD0,	/* 31 "l"	*/	
  0,		/* 32 		*/	
  0,		/* 33 		*/	
  p_983C,	/* 34 "mod"	*/	
  p_9838,	/* 35 "and"	*/	
  p_9834,	/* 36 "mul"	*/	
  p_9828,	/* 37 "add"	*/	
  p_9820,	/* 38 "sub"	*/	
  p_9854,	/* 39 "div"	*/	
  p_8DD0,	/* 40 "l"	*/	
  p_986B,	/* 41 "z"	*/	
  p_8D09,	/* 42 "r"	*/	
  p_9850,	/* 43 "xor"	*/	
  p_9851,	/* 44 "or"	*/	
  0,		/* 45 		*/	
  p_9873,	/* 46 "ge"	*/	
  p_8D09,	/* 47 "r"	*/	
  0,		/* 48 		*/	
  0,		/* 49 		*/	
  0,		/* 50 		*/	
  0,		/* 51 		*/	
  0,		/* 52 		*/	
  0,		/* 53 		*/	
  0,		/* 54 		*/	
  0,		/* 55 		*/	
  0,		/* 56 		*/	
  0,		/* 57 		*/	
  p_9850,	/* 58 "xor" 	*/	
  0,		/* 59 		*/	
  p_9851,	/* 60 "or"	*/	
  0,		/* 61 		*/	
  0,		/* 62 		*/	
  p_9870,	/* 63 "-1"	*/	
  0,		/* 64 		*/	
  0,		/* 65 		*/	
  0,		/* 66 		*/	
  0,		/* 67 		*/	
  0,		/* 68 		*/	
  0,		/* 69 		*/	
  0,		/* 70 		*/	
  0		/* 71 		*/	
};

struct zzz {
  char		c_0;
  char		c_1;
  char		c_2;
  char		c_3;
  char		c_4;
  char		c_5;
  char 	      * p_6;
  char	      * p_8;
};

struct zzz array_80EF[] = {
  {    0,    0,    0,    0,    0,    0,      0,      0 },	/*   0 */
  {    0,    0,    0, 0x1C, 0x48, 0x48,      0, p_8D3C },	/*   1 */
  {    1,    0,    0, 0x2C, 0x49, 0x4A, p_9641, p_8B33 },	/*   2 */
  {    2,    0,    0, 0x23, 0x49, 0x4A, p_9668, p_8B33 },	/*   3 */
  {    3,    0,    0, 0x0F, 0x49, 0x4B, p_96D0, p_8B33 },	/*   4 */
  {    3,    0,    0, 0x0F, 0x49, 0x4C, p_96E4, p_8B33 },	/*   5 */
  {    3,    0,    0, 0x13, 0x49, 0x4B, p_96EE, p_8B33 },	/*   6 */
  {    0,    0, 0x12, 0x0A, 0x4D, 0x4E, p_8FEA, p_8B33 },	/*   7 */
  {    0,    0,    0,    5, 0x4F,    0, p_980C, p_8D3C },	/*   8 */
  {    0,    0,    0,    4, 0x50, 0x4F, p_97DE, p_8B33 },	/*   9 */
  {    0,    0,    0,    4, 0x51, 0x4F, p_9600, p_8B33 },	/*  10 */
  {    4,    0,    0, 0x0B, 0x52,    0,      0, p_8B33 },	/*  11 */
  {    5,    0,    0, 0x0B, 0x53,    0,      0, p_8B33 },	/*  12 */
  {    6,    0,    0, 0x0B, 0x54,    0,      0, p_8B33 },	/*  13 */
  {    3,    6,    0, 0x0B, 0x55,    0,      0, p_8B33 },	/*  14 */
  {    3,    0,    6, 0x0B, 0x56,    0, p_9744, p_8B33 },	/*  15 */
  {    0,    0,    0, 0x1A, 0x4F,    0, p_9867, p_8B33 },	/*  16 */
  {    3,    0,    0, 0x21, 0x49, 0x4A, p_9756, p_8B33 },	/*  17 */
  {    3,    0,    0, 0x46, 0x56,    0,      0, p_8B33 },	/*  18 */
  {    3,    0,    0, 0x31, 0x4A,    0, p_97D7, p_8B33 },	/*  19 */
  {    0,    0,    0, 0x57,    0,    0,      0, p_8B33 },	/*  20 */
  {    3,    0,    0, 0x55,    0,    0,      0, p_8B33 },	/*  21 */
  {    7,    0,    0, 0x21, 0x49, 0x4A, p_8BE2, p_8B33 },	/*  22 */
  {    8,    0,    0, 0x31, 0x58,    0, p_97D0, p_8B33 },	/*  23 */
  {    5,    0,    0, 0x31, 0x4A,    0, p_94C8, p_8B33 },	/*  24 */
  {    5,    0,    0, 0x53,    0,    0,      0, p_8B33 },	/*  25 */
  {    6,    0,    0, 0x21, 0x49, 0x4A, p_9107, p_8D3C },	/*  26 */
  {    6,    0,    0, 0x31, 0x59,    0, p_97C2, p_8B33 },	/*  27 */
  {    6,    0,    0, 0x5A,    0,    0,      0, p_8B33 },	/*  28 */
  {    0,    0,    0, 0x5B,    0,    0,      0, p_8B33 },	/*  29 */
  {    0,    1,    0, 0x55,    0,    0,      0, p_8D3C },	/*  30 */
  {    0,    0,    1, 0x55,    0,    0, p_979E, p_8D9E },	/*  31 */
  {    0,    0,    0, 0x1B, 0x4A,    0,      0, p_97FD },	/*  32 */
  {    0,    0,    0,    9, 0x5C,    0,      0, p_8D3C },	/*  33 */
  {    0,    0,    0, 0x43,    0,    0,      0, p_986D },	/*  34 */
  {    6,    0,    0, 0x14, 0x59,    0,      0, p_8D3C },	/*  35 */
  {    0,    0,    0, 0x0E, 0x59, 0x4A,      0, p_9811 },	/*  36 */
  {    0,    0,    0, 0x49,    0,    0,      0, p_8D3C },	/*  37 */
  {    3,    0,    0, 0x55,    0,    0,      0, p_8D3C },	/*  38 */
  {    3,    0, 0x1A, 0x56,    0,    0, p_9744, p_8D9E },	/*  39 */
  {    0,    0,    0, 0x5A,    0,    0,      0, p_97A6 },	/*  40 */
  {    0,    0,    0, 0x5E,    0,    0,      0, p_97A6 },	/*  41 */
  {    5,    0,    0, 0x53,    0,    0,      0, p_9796 },	/*  42 */
  {    3,    6,    0, 0x55,    0,    0, p_978E, p_9879 },	/*  43 */
  {    3,    0,    2, 0x56,    0,    0, p_94DA, p_9879 },	/*  44 */
  {    0,    0,    0, 0x57,    0,    0, p_97BB, p_9879 },	/*  45 */
  {    0,    0,    0, 0x5F,    0,    0,      0, p_987B },	/*  46 */
  {    0,    0,    0, 0x5A,    0,    0, p_9786, p_9879 },	/*  47 */
  {    4,    0, 0x10, 0x60,    0,    0, p_8CD7, p_9864 },	/*  48 */
  {    0,    0,    0, 0x11, 0x4E, 0x4E,      0, p_984C },	/*  49 */
  {    0,    0,    0, 0x17,    0,    0,      0, p_94B4 },	/*  50 */
  {    3,    0,    1, 0x62,    0,    0, p_977E, p_9776 },	/*  51 */
  {    3,    0,    1, 0x5C,    0,    0, p_970C, p_9702 },	/*  52 */
  {    6,    0, 0x0E, 0x5C,    0,    0, p_970C, p_9702 },	/*  53 */
  {    0,    0, 0x0E, 0x57,    0,    0, p_95C8, p_95E4 },	/*  54 */
  {    6,    0, 0x0E, 0x49,    0,    0, p_9451, p_9323 },	/*  55 */
  {    6,    0, 0x0E, 0x0D, 0x64,    0, p_8DA1, p_8D70 },	/*  56 */
  {    0,    0, 0x51, 0x65,    0,    0, p_8B8C, p_8CA1 },	/*  57 */
  {    0,    0, 0x18, 0x57,    0,    0, p_95C8, p_95E4 },	/*  58 */
  {    6,    0, 0x18, 0x49,    0,    0, p_9451, p_947B },	/*  59 */
  {    6,    0, 0x1D, 0x0D, 0x54,    0, p_906D, p_908C },	/*  60 */
  {    0,    0,    0, 0x63,    0,    0,      0, p_8D3C },	/*  61 */
  {    0,    0,    0, 0x47, 0x52,    0,      0, p_9380 },	/*  62 */
  {    1,    0,    0,    7, 0x5D, 0x4A, p_960D, p_8B33 },	/*  63 */
  {    0,    0,    0,    8, 0x68, 0x51, p_923B, p_8B33 },	/*  64 */
  {    0,    0,    0, 0x51,    0,    0, p_91E9, p_8D3C },	/*  65 */
  {    0,    0,    0,    1, 0x51,    0, p_9289, p_8B33 },	/*  66 */
  {    0,    0,    0, 0x3D, 0x69, 0x51, p_923B, p_8B33 },	/*  67 */
  {    0,    0,    0, 0x51,    0,    0, p_9609, p_8D3C },	/*  68 */
  {    0,    0,    0, 0x50,    0,    0, p_953F, p_8B33 },	/*  69 */
  {    3,    0,    0, 0x5D,    0,    0,      0, p_8D3C },	/*  70 */
  {    3,    0, 0x1A, 0x0D, 0x6B,    0, p_95AA, p_8D9E },	/*  71 */
  {    3,    0, 0x1A, 0x0D, 0x6C,    0, p_964E, p_8D9E },	/*  72 */
  {    3,    0, 0x5A, 0x49,    0,    0, p_977E, p_8D9E },	/*  73 */
  {    0,    0,    0, 0x1C, 0x48, 0x55,      0, p_956B },	/*  74 */
  {    0,    0,    0, 0x21, 0x49, 0x55, p_976E, p_956B },	/*  75 */
  {    3,    0,    0, 0x30, 0x69, 0x6D,      0, p_956B },	/*  76 */
  {    3,    0, 0x1A, 0x14, 0x50,    0, p_91D1, p_8D9E },	/*  77 */
  {    3,    0, 0x1A, 0x14, 0x51,    0, p_8FC8, p_8D9E },	/*  78 */
  {    3,    0,    0, 0x14, 0x55,    0,      0, p_9380 },	/*  79 */
  {    3,    0, 0x5A, 0x14, 0x5A,    0, p_96DA, p_8D9E },	/*  80 */
  {    9,    0, 0x52, 0x14, 0x53,    0, p_9425, p_96B5 },	/*  81 */
  {    3,    0, 0x5A, 0x14, 0x53,    0, p_96AF, p_8D9E },	/*  82 */
  {    3,    0,    0, 0x21, 0x5C, 0x56, p_96F8, p_956B },	/*  83 */
  {    3,    0, 0x5A, 0x6E,    0,    0, p_96C5, p_8D9E },	/*  84 */
  {    0,    0,    0, 0x1F, 0x55, 0x6F, p_961A, p_9380 },	/*  85 */
  {    0,    0,    0, 0x1F, 0x55, 0x70, p_8E63, p_9380 },	/*  86 */
  {    0,    0,    0, 0x28, 0x61, 0x6F, p_957D, p_9380 },	/*  87 */
  {    0,    0,    0, 0x28, 0x61, 0x70, p_8E34, p_9380 },	/*  88 */
  {    0,    0,    0, 0x0E, 0x56, 0x5D, p_97C9, p_9380 },	/*  89 */
  { 0x0A,    0,    0,    7, 0x56, 0x5D, p_9816, p_9380 },	/*  90 */
  {    0,    0,    0, 0x25, 0x61, 0x5D, p_973B, p_9380 },	/*  91 */
  { 0x0A,    0,    0, 0x23, 0x61, 0x5D, p_97B4, p_9380 },	/*  92 */
  {    3,    0, 0x1A, 0x0F, 0x49, 0x4B, p_951E, p_8D9E },	/*  93 */
  {    0,    0, 0x1B, 0x0F, 0x61, 0x71, p_956E, p_8D9E },	/*  94 */
  {    0,    0,    0, 0x3F, 0x56,    0, p_982C, p_9380 },	/*  95 */
  {    0,    0,    0, 0x15, 0x56,    0, p_9830, p_9380 },	/*  96 */
  {    3,    0,    1, 0x5C,    0,    0, p_970C, p_8D9E },	/*  97 */
  {    0,    0, 0x12, 0x0A, 0x4D, 0x4E, p_8EBB, p_981B },	/*  98 */
  {    0,    0,    0, 0x19, 0x72, 0x73, p_8FC4, p_9380 },	/*  99 */
  {    0,    0,    0, 0x72,    0,    0, p_96A4, p_8B33 },	/* 100 */
  {    5,    0,    0, 0x53,    0,    0,      0, p_8D3C },	/* 101 */
  {    6,    0,    0, 0x54,    0,    0,      0, p_8D3C },	/* 102 */
  {    3,    0,    0, 0x56,    0,    0,      0, p_8D3C },	/* 103 */
  {    0,    0,    0, 0x43,    0,    0,      0, p_976B },	/* 104 */
  {    0,    3,    0, 0x55,    0,    0,      0, p_8D3C },	/* 105 */
  {    0,    0,    3, 0x5D,    0,    0, p_977E, p_8D9E },	/* 106 */
  {    0, 0x0D,    0, 0x5A,    0,    0,      0, p_8D3C },	/* 107 */
  {    0, 0x0E, 0x0D, 0x5A,    0,    0, p_974D, p_8D9E },	/* 108 */
  {    0, 0x19,    0, 0x5A,    0,    0,      0, p_8D3C },	/* 109 */
  {    0,    0,    0, 0x64,    0,    0,      0, p_8D3C },	/* 110 */
  {    0,    0,    0, 0x0D, 0x59,    0,      0, p_8D3C },	/* 111 */
  {    0,    0,    0, 0x42,    0,    0,      0, p_986D },	/* 112 */
  {    0,    0,    0, 0x44,    0,    0, p_8F82, p_9848 },	/* 113 */
  {    0,    0,    0, 0x17,    0,    0,      0, p_8B33 },	/* 114 */
  {    0,    0,    0, 0x44,    0,    0,      0, p_986D },	/* 115 */
  {    0,    0,    0,    2, 0x67, 0x75,      0, p_91CE },	/* 116 */
  {    0,    0,    0,    2, 0x76, 0x75,      0, p_9802 },	/* 117 */
  {    0,    0,    0,    2, 0x56, 0x75, p_97EB, p_9802 },	/* 118 */
  { 0x0A,    0,    0,    2, 0x56, 0x5D, p_9807, p_91CE },	/* 119 */
  { 0x0A,    0,    0,    2, 0x56, 0x70, p_926F, p_9802 },	/* 120 */
  { 0x0B,    0,    1,    2, 0x49, 0x75, p_952F, p_91CE },	/* 121 */
  { 0x0B,    0, 0x1C,    2, 0x5C, 0x75, p_9143, p_91CE },	/* 122 */
  { 0x0B,    0,    1,    2, 0x52, 0x75, p_92BD, p_91CE },	/* 123 */
  { 0x0B,    0,    1,    2, 0x5D, 0x75, p_952F, p_91CE },	/* 124 */
  { 0x0B,    0,    0, 0x1E, 0x5D, 0x75, p_9699, p_986A },	/* 125 */
  { 0x0B,    0,    0, 0x2E, 0x5D, 0x75, p_9699, p_986B },	/* 126 */
  { 0x0C,    0,    1,    2, 0x5D, 0x75, p_902D, p_91CE },	/* 127 */
  { 0x0C,    0,    0, 0x1E, 0x5D, 0x75, p_968E, p_986A },	/* 128 */
  { 0x0C,    0,    0, 0x2E, 0x5D, 0x75, p_968E, p_986B },	/* 129 */
  { 0x0B,    0,    0,    2, 0x54, 0x64, p_959B, p_91CE },	/* 130 */
  {    0,    0,    1,    2, 0x54, 0x64, p_92A3, p_9802 },	/* 131 */
  {    0,    0, 0x52,    2, 0x53, 0x5F, p_9199, p_9802 },	/* 132 */
  {    0,    0,    0, 0x5C,    0,    0,      0, p_8D3C },	/* 133 */
  {    0,    0,    0, 0x0D, 0x54,    0,      0, p_97F1 },	/* 134 */
  {    0, 0x0E,    0, 0x5A,    0,    0,      0, p_9380 },	/* 135 */
  {    0, 0x0D, 0x0E, 0x5A,    0,    0, p_974D, p_8D9E },	/* 136 */
  {    0,    0,    0, 0x0F, 0x63, 0x4A,      0, p_9634 },	/* 137 */
  {    0,    0,    0, 0x0E, 0x57, 0x78,      0, p_9811 },	/* 138 */
  {    0,    0,    0, 0x57,    0,    0,      0, p_9844 },	/* 139 */
  {    0,    0,    9, 0x0E, 0x5C, 0x78, p_970C, p_97F7 },	/* 140 */
  { 0x0D,    0,    0, 0x0F, 0x57, 0x4A,      0, p_9390 },	/* 141 */
  { 0x0E,    0,    0, 0x45,    0,    0,      0, p_986D },	/* 142 */
  { 0x0D,    0,    0, 0x25, 0x57, 0x4A, p_96D0, p_8D3C },	/* 143 */
  {    0,    0,    0, 0x25, 0x57, 0x5E, p_9729, p_8D3C },	/* 144 */
  {    0,    0,    0, 0x21, 0x57, 0x59, p_97AD, p_8D3C },	/* 145 */
  {    0,    0,    0, 0x21, 0x57, 0x5C, p_9720, p_8D3C },	/* 146 */
  {    0,    0,    0, 0x21, 0x5C, 0x57, p_9732, p_8C23 },	/* 147 */
  {    0,    0,    0, 0x1B, 0x4A,    0,      0, p_985C },	/* 148 */
  {    0,    0,    0, 0x42,    0,    0,      0, p_986D },	/* 149 */
  {    0,    0,    0, 0x43,    0,    0,      0, p_9860 },	/* 150 */
  {    5,    0,    0, 0x53,    0,    0, p_954F, p_8B33 },	/* 151 */
  {    3,    0,    0, 0x49,    0,    0,      0, p_8D3C },	/* 152 */
  {    3,    0,    0, 0x0D, 0x5A,    0,      0, p_9087 },	/* 153 */
  { 0x0F,    0,    0, 0x43,    0,    0,      0, p_976B },	/* 154 */
  { 0x10,    0,    0, 0x43,    0,    0,      0, p_8B33 },	/* 155 */
  {    3,    0,    0, 0x25, 0x49, 0x6F, p_96D0, p_8D3C },	/* 156 */
  {    3,    0,    0, 0x25, 0x49, 0x4C, p_96E4, p_8D3C },	/* 157 */
  {    0,    0, 0x52, 0x47, 0x54,    0, p_8BB7, p_97E5 },	/* 158 */
  {    0,    0,    0, 0x21, 0x65, 0x64, p_8E90, p_9380 },	/* 159 */
  {    6,    0,    0, 0x30, 0x69, 0x6D,      0, p_956B },	/* 160 */
  {    0,    0, 0x18, 0x59,    0,    0, p_977E, p_8D9E },	/* 161 */
  {    6,    0, 0x18, 0x5C,    0,    0, p_970C, p_8D9E },	/* 162 */
  {    6,    0, 0x18, 0x49,    0,    0, p_9451, p_8D9E },	/* 163 */
  {    0,    0,    0, 0x1C, 0x48, 0x5A,      0, p_956B },	/* 164 */
  {    0,    0, 0x18, 0x57,    0,    0, p_95C8, p_8D9E },	/* 165 */
  {    6,    0, 0x17, 0x22, 0x52, 0x64, p_9255, p_9380 },	/* 166 */
  {    6,    0, 0x17,    6, 0x54, 0x64, p_940F, p_9380 },	/* 167 */
  {    0,    0,    0, 0x2F, 0x5A, 0x6F, p_9490, p_9380 },	/* 168 */
  {    0,    0,    0, 0x1F, 0x54, 0x6F, p_95D6, p_9380 },	/* 169 */
  {    6,    0,    1, 0x28, 0x52, 0x70, p_9255, p_9380 },	/* 170 */
  {    0,    0,    1, 0x1F, 0x54, 0x70, p_92D7, p_9380 },	/* 171 */
  {    0,    0,    0, 0x13, 0x66, 0x6F, p_9383, p_9380 },	/* 172 */
  {    0,    0,    0, 0x0F, 0x66, 0x6F, p_939B, p_9380 },	/* 173 */
  {    2,    0,    0, 0x23, 0x66, 0x4A, p_94EB, p_9380 },	/* 174 */
  {    2,    0,    0,    7, 0x5A, 0x4A, p_958C, p_9380 },	/* 175 */
  {    1,    0,    0, 0x2C, 0x66, 0x4A, p_94FC, p_9380 },	/* 176 */
  {    1,    0,    0, 0x3C, 0x5A, 0x4A, p_95B9, p_9380 },	/* 177 */
  {    6,    0, 0x5C,    7, 0x5D, 0x5D, p_8D3E, p_90A7 },	/* 178 */
  {    6,    0,    1, 0x23, 0x66, 0x5D, p_8D0B, p_9380 },	/* 179 */
  {    6,    0, 0x1D, 0x0F, 0x63, 0x4A, p_90CA, p_9380 },	/* 180 */
  {    6,    0, 0x1D, 0x13, 0x63, 0x4A, p_8F5D, p_9380 },	/* 181 */
  {    6,    0, 0x18, 0x0D, 0x6B,    0, p_9125, p_8D9E },	/* 182 */
  {    6,    0, 0x1D, 0x0D, 0x6C,    0, p_8EE5, p_8D9E },	/* 183 */
  {    6,    0, 0x1D, 0x0D, 0x54,    0, p_906D, p_8D9E },	/* 184 */
  {    6,    0, 0x1A, 0x52,    0,    0, p_8F0D, p_9380 },	/* 185 */
  {    6,    0, 0x18, 0x14, 0x50,    0, p_91D1, p_8D9E },	/* 186 */
  {    6,    0, 0x18, 0x14, 0x51,    0, p_8FA5, p_8D9E },	/* 187 */
  {    0,    0, 0x18, 0x25, 0x57, 0x5E, p_93CB, p_8D9E },	/* 188 */
  {    6,    0,    0, 0x25, 0x66, 0x6F, p_965B, p_9380 },	/* 189 */
  {    6,    0,    0, 0x26, 0x66, 0x6F, p_9627, p_9380 },	/* 190 */
  {    6,    0,    0, 0x25, 0x66, 0x4C, p_9675, p_9380 },	/* 191 */
  {    6,    0,    0, 0x26, 0x63, 0x5E, p_950D, p_9380 },	/* 192 */
  {    6,    0,    0, 0x25, 0x63, 0x5E, p_9682, p_9380 },	/* 193 */
  {    6,    0,    0, 0x21, 0x5C, 0x5A, p_96F8, p_956B },	/* 194 */
  {    6,    0,    0, 0x21, 0x49, 0x5A, p_9466, p_956B },	/* 195 */
  {    6,    0,    0, 0x21, 0x52, 0x5E, p_90AB, p_956B },	/* 196 */
  {    6,    0,    0, 0x12, 0x54, 0x5E, p_955F, p_9380 },	/* 197 */
  {    0,    0,    0, 0x0E, 0x5A, 0x6F, p_9390, p_9380 },	/* 198 */
  {    0,    0,    0, 0x0E, 0x5A, 0x4C, p_96BA, p_9380 },	/* 199 */
  {    6, 0x1D, 0x0E, 0x0E, 0x5A, 0x59, p_94B6, p_8D9E },	/* 200 */
  {    6,    0,    0, 0x0E, 0x54, 0x5E, p_9716, p_9380 },	/* 201 */
  {    0,    0, 0x0E, 0x15, 0x5E,    0, p_936B, p_8D9E },	/* 202 */
  {    0,    0,    0, 0x21, 0x57, 0x5A, p_95F2, p_956B },	/* 203 */
  {    6,    0, 0x58, 0x6E,    0,    0, p_9353, p_8D9E },	/* 204 */
  { 0x11,    0, 0x58, 0x14, 0x6A,    0, p_94A4, p_8D9E },	/* 205 */
  { 0x12,    0, 0x18, 0x14, 0x56,    0, p_90E9, p_8D9E },	/* 206 */
  {    0,    0,    0,    9, 0x5B,    0,      0, p_8D3C },	/* 207 */
  { 0x13,    0, 0x52, 0x14, 0x53,    0, p_9425, p_9597 },	/* 208 */
  {    6,    0,    0, 0x14, 0x5A,    0,      0, p_9380 },	/* 209 */
  {    6,    0,    0, 0x14, 0x53,    0,      0, p_9597 },	/* 210 */
  {    8,    0,    1, 0x15, 0x53,    0, p_943B, p_9380 },	/* 211 */
  {    5,    0, 0x0F, 0x5C,    0,    0, p_930A, p_8D9E },	/* 212 */
  {    0,    0, 0x0F, 0x43,    0,    0, p_93F9, p_8D9E },	/* 213 */
  {    5,    0, 0x0F, 0x49,    0,    0, p_8E03, p_8D9E },	/* 214 */
  {    5,    0,    0, 0x6E,    0,    0,      0, p_8D3C },	/* 215 */
  {    5,    0,    0, 0x30, 0x69, 0x6D,      0, p_956B },	/* 216 */
  {    5,    0, 0x54, 0x0D, 0x54,    0, p_8B34, p_90A7 },	/* 217 */
  {    7,    0, 0x0C, 0x0E, 0x53, 0x4A, p_8C67, p_9380 },	/* 218 */
  {    5,    0, 0x52, 0x22, 0x52, 0x5F, p_91B5, p_981B },	/* 219 */
  {    5,    0, 0x52, 0x0F, 0x52,    0, p_933B, p_981B },	/* 220 */
  {    5,    0, 0x52,    6, 0x53, 0x5F, p_93B3, p_9380 },	/* 221 */
  {    7,    0, 0x4F, 0x28, 0x52, 0x70, p_904D, p_8D9E },	/* 222 */
  {    7,    0, 0x54, 0x1F, 0x53, 0x70, p_917D, p_9380 },	/* 223 */
  {    5,    0,    0, 0x21, 0x5C, 0x53, p_92F1, p_956B },	/* 224 */
  {    5,    0,    0, 0x21, 0x49, 0x53, p_8DD2, p_956B },	/* 225 */
  {    5,    0, 0x51, 0x21, 0x52, 0x5F, p_8ADB, p_8B88 },	/* 226 */
  {    7,    0, 0x11, 0x15, 0x5F,    0, p_8C25, p_8B88 },	/* 227 */
  { 0x14,    0, 0x54, 0x14, 0x64,    0, p_900C, p_90A7 },	/* 228 */
  { 0x14,    0, 0x54, 0x14, 0x56,    0, p_8F35, p_90A7 },	/* 229 */
  { 0x15,    0, 0x4F, 0x14, 0x64,    0, p_975E, p_8D9E },	/* 230 */
  { 0x15,    0, 0x4F, 0x14, 0x55,    0, p_93E2, p_8D9E },	/* 231 */
  { 0x16,    0, 0x52, 0x14, 0x53,    0, p_91ED, p_9380 },	/* 232 */
  { 0x17,    0, 0x52, 0x14, 0x54,    0, p_9207, p_981B },	/* 233 */
  { 0x18,    0, 0x52, 0x14, 0x56,    0, p_9221, p_981B },	/* 234 */
  { 0x19,    0, 0x52, 0x14, 0x53,    0, p_9425, p_9380 },	/* 235 */
  {    0,    0,    0, 0x14, 0x53,    0,      0, p_9380 },	/* 236 */
  {    0,    0,    0, 0x43,    0,    0,      0, p_9766 },	/* 237 */
  {    0,    0,    0, 0x76,    0,    0,      0, p_8D3C },	/* 238 */
  {    0,    0,    0, 0x0D, 0x77,    0,      0, p_9712 },	/* 239 */
  {    3,    0,    0, 0x0D, 0x54,    0,      0, p_9087 },	/* 240 */
  { 0x1A,    0,    0, 0x43,    0,    0,      0, p_8B33 },	/* 241 */
  { 0x1B,    0,    0, 0x43,    0,    0,      0, p_8B33 },	/* 242 */
  {    0, 0x0D,    0, 0x5B,    0,    0,      0, p_8D3C },	/* 243 */
  {    0,    0, 0x0D, 0x0D, 0x54,    0, p_974D, p_8D9E },	/* 244 */
  {    0, 0x0E,    0, 0x5B,    0,    0,      0, p_8D3C },	/* 245 */
  {    0,    0,    0, 0x0D, 0x54,    0,      0, p_8D3C },	/* 246 */
  {    4,    0, 0x0C, 0x21, 0x60, 0x52, p_9160, p_956B },	/* 247 */
  {    0,    0, 0x18, 0x5C,    0,    0, p_977E, p_8D9E },	/* 248 */
  {    0,    0,    0, 0x0D, 0x5A,    0,      0, p_8D3C },	/* 249 */
  {    4,    0,    0, 0x6E,    0,    0,      0, p_9840 },	/* 250 */
  { 0x1C,    0,    0, 0x14, 0x5B,    0,      0, p_8D3C },	/* 251 */
  { 0x1D,    0,    0, 0x43,    0,    0,      0, p_976B },	/* 252 */
  { 0x1E,    0,    0, 0x43,    0,    0,      0, p_8B33 },	/* 253 */
};
  
char p_8ADB[] = {
  'p','o','p',' ','d','e','\n',
  'l','d',' ','(','h','l',')',',','e','\n',
  'i','n','c','\t','h','l','\n',
  'l','d',' ','(','h','l',')',',','d','\n',
  'i','n','c',' ','h','l','\n',
  'p','o','p',' ','b','c','\n',
  'l','d',' ','(','h','l',')',',','c','\n',
  'i','n','c',' ','h','l','\n',
  'l','d',' ','(','h','l',')',',','b','\n',
  'l','d','\t','l',',','c','\n',
  'l','d','\t','h',',','b'};
char p_8B33[] = { 0 };
char p_8B34[] = {
  'l','d',' ','X','0','0','0','N',',','(','G','L',')','\n',
  'i','n','c',' ','G','L','\n',
  'l','d',' ','X','0','0','1','N',',','(','G','L',')','\n',
  'i','n','c',' ','G','L','\n',
  'l','d',' ','X','1','N',',','(','G','L',')','\n',
  'i','n','c','\t','G','L','\n',
  'l','d',' ','X','0','1','1','N',',','(','G','L',')','\n',
  'l','d',' ','X','0','1','0','N',','};
char p_8B88[] = "X1N";
char p_8B8C[] = {
  'l','d',' ','e',',','(','h','l',')','\n',
  'i','n','c',' ','h','l','\n',
  'l','d',' ','d',',','(','h','l',')','\n',
  'd','e','c',' ','h','l','\n',
  'e','x',' ','d','e',',','h','l','\n'};
char p_8BB7[] = {
  'g','l','o','b','a','l',' ','b','f','e','x','t','\n',
  'c','a','l','l',' ','b','f','e','x','t','\n',
  'd','e','f','b',' ','T','N','+','(','C','N','.','s','h','l','.','4',')',0};

char p_8BE2[] = {
  'l','d',' ','L',',','.','l','o','w','.','V','R','\n',
  'l','d',' ','~','+','1','L',',','.','h','i','g','h','.','V','R','\n',
  'l','d',' ','~','+','2','L',',','.','l','o','w','.','V','+','2','R','\n',
  'l','d',' ','~','+','3','L',',','.','h','i','g','h','.','V','+','2'};
char p_8C23[] =	 "R";
char p_8C25[] =	 "ld hl,ON\n"
	         "pop bc\n"
	         "or a\n"
	         "sbc hl,bc\n"
	         "pop\tbc\n"
	         "ex de,hl\n"
	         "ld hl,ON\n"
	         "sbc hl,bc";
char p_8C67[] =	 "ex de,hl\n"
	         "ld bc,VR\n"
	         "add hl,bc\n"
	         "ex de,hl\n"
	         "ld bc,V+2R\n"
	         "adc hl,bc";
char p_8CA1[] =	 "ex X10N,GL\n"
	         "global bfins\n"
	         "call bfins\n"
	         "defb TN+(CN.shl.4)";
 char p_8CD7[] ={'l','d',' ','h','l',',','-','Z','N','\n',
	         'a','d','d','\t','h','l',',','s','p','\n',
	         'l','d',' ','s','p',',','h','l','\n',
	         'e','x',' ','d','e',',','h','l','\n',
	         'l','d',' ','b','c',',','Z','N','\n',
	         'l','d','i'};
char p_8D09[] =	 "r";
char p_8D0B[] = {'l','d',' ','a',',','G','0','L','\n',
	         'O','N',' ','R','\n',
	         'l','d',' ','G','0','L',',','a','\n',
	         'l','d',' ','a',',','G','1','L','\n',
	         'O','N','\t','~','+','1','R','\n',
	         'l','d',' ','G','1','L',',','a','\n'};
 char p_8D3C[] = "L";
 char p_8D3E[] = "ld a,L\n"
	         "ON R\n"
	         "ld X00N,a\n"
	         "ld a,~+1L\n"
	         "ON\t~+1R\n"
	         "ld X01N,a";
char p_8D70[] = {'e','x',' ','d','e',',','h','l','\n',
	         'l','d',' ','(','X','N',')',',','G','1','L','\n',
	         'd','e','c',' ','X','N','\n',
	         'l','d',' ','(','X','N',')',',','G','0','L','\n',
	         'e','x','\t','d','e',','};
char p_8D9E[] =	 "XN";
char p_8DA1[] = {'e','x',' ','d','e',',','h','l','\n',
	         'l','d',' ','G','0','L',',','(','X','N',')','\n',
	         'i','n','c',' ','X','N','\n',
	         'l','d',' ','G','1','L',',','(','X','N',')','\n',
	         'e','x','\t','d','e',',','h'};
char p_8DD0[] =	 "l";
char p_8DD2[] =	 "ld L,G00R\n"
	         "ld ~+1L,G01R\n"
	         "ld ~+2L,G10R\n"
	         "ld ~+3L,G11R";
char p_8E03[] =	 "ld X00N,L\n"
	         "ld X01N,~+1L\n"
	         "ld X10N,~+2L\n"
	         "ld X11N,~+3L";
char p_8E34[] =	 "inc GR\n"
	         "dec GR\n"
	         "jr z,2f\n"
	         "1:\n"
	         "sONAN GL\n"
	         "djnz 1b\n"
	         "2:\n"
	         "L";
char p_8E63[] =	 "inc GR\n"
	         "dec GR\n"
	         "jr z,2f\n"
	         "1:\n"
	         "sONAN GL\n"
	         "djnz 1b\n"
	         "2:";
char p_8E90[] =	 "global bfins\n"
	         "call bfins\n"
	         "defb TL+(CL.shl.4)";
char p_8EBB[] =	 "call L\n"
	         "exx\n"
	         "ld hl,R\n"
	         "add hl,sp\n"
	         "ld sp,hl\n"
	         "exx";
char p_8EE5[] =	 "ld X0N,(GL)\n"
	         "inc GL\n"
	         "ld X1N,(GL)\n"
	         "dec GL\n"
	         "L";
char p_8F0D[] =	 "ld XN,(GL)\n"
	         "inc GL\n"
	         "ld\tG1L,(GL)\n"
	         "ld G0L,XN";
char p_8F35[] =	 "ld e,a\n"
	         "rla\n"
	         "sbc a,a\n"
	         "ld d,a\n"
	         "ld l,a\n"
	         "ld h,a";
char p_8F5D[] =	 "ld XN,-VR\n"
	         "add\tGL,XN\n"
	         "L\n"
	         "or a\n"
	         "sbc GL,XN";
char p_8F82[] =	 "psect data\n"
	         "eFN: deff SN\n"
	         "psect text";
char p_8FA5[] = {'U','0',':','\n',
	         'l','d',' ','X','N',',','1','\n',
	         'j','p',' ','U','2','f','\n',
	         'U','1',':','\n',
	         'l','d',' ','X','N',',','0','\n'};
char p_8FC4[] =	 "U2:";
char p_8FC8[] =	 "U0:\n"
	         "ld XN,1\n"
	         "p U2f\n"
	         "U1:\n"
	         "ld XN,0\n"
	         "U2:";
char p_8FEA[] =	 "call L\n"
	         "ld hl,R\n"
	         "add hl,sp\n"
	         "ld\tsp,hl";
char p_900C[] =	 "ld a,d\n"
	         "rla\n"
	         "sbc a,a\n"
	         "ld l,a\n"
	         "ld h,a";
char p_902D[] =	 "ld XN,L\n"
	         "or ~+1L\n"
	         "or ~+2L\n"
	         "or ~+3L";
char p_904D[] =	 "global\tasANlONsh\n"
	         "call\tasANlONsh";
char p_906D[] = {'l','d',' ','X','0','N',',','(','G','L',')','\n',
	         'i','n','c',' ','G','L','\n',
	         'l','d',' ','X','1','N',','};
char p_9087[] =	 "(GL)";
char p_908C[] = {'l','d',' ','(','G','L',')',',','X','1','N','\n',
	         'd','e','c',' ','G','L','\n',
	         'l','d',' ','(','G','L',')',','};
char p_90A7[] =	 "X0N";
char p_90AB[] =	 "ld (GL),G0R\n"
	         "inc GL\n"
	         "ld (GL),G1R";
char p_90CA[] =	 "ld XN,VR\n"
	         "add GL,XN\n"
	         "L\n"
	         "sbc GL,XN";
char p_90E9[] =	 "ld X0N,a\n"
	         "rla\n"
	         "sbc a,a\n"
	         "ld X1N,a";
char p_9107[] =	 "ld L,.low.VR\n"
	         "ld ~+1L,.high.VR";
char p_9125[] =	 "ld X0N,(GL+0)\n"
	         "ld X1N,(GL+1)\n"
	         "L";
char p_9143[] =	 "ld X0N,(L)\n"
	         "ld\ta,X00N\n"
	         "or X01N";
char p_9160[] =	 "push hl\n"
	         "ld XN,ZN\n"
	         "ldir\n"
	         "pop hl";
char p_917D[] =	 "global\tANlONsh\n"
	         "call ANlONsh";
char p_9199[] =	 "global\tALrelop\n"
	         "call ALrelop";
char p_91B5[] = {'g','l','o','b','a','l','\t','a','s','A','N','l','O','N','\n',
		 'c','a','l','l',' ','a','s','A','N','l'};
char p_91CE[] =	 "ON";
char p_91D1[] = {'l','d',' ','X','N',',','1','\n',
	         'j','p',' ','L',',','U','0','f','\n',
	         'd','e','c','\t','X','N','\n'};
char p_91E9[] =	 "U0:";
char p_91ED[] =	 "global\tALltof\n"
	         "call ALltof";
char p_9207[] =	 "global\tALitof\n"
	         "call ALitof";
char p_9221[] =	 "global\tALbtof\n"
	         "call ALbtof";
char p_923B[] =	 "U1:jp ~-1U1f\n"
	         "U0:jp ~-1U0f";
char p_9255[] =	 "global\tasANON\n"
	         "call asANON";
char p_926F[] =	 "global\tbrelop\n"
	         "call brelop";
char p_9289[] =	 "U1:jp ~-1U0f\n"
	         "U0:jp ~-1U1f";
char p_92A3[] =	 "global wrelop\n"
	         "call wrelop";
char p_92BD[] =	 "ld XN,(GL)\n"
	         "inc GL\n"
	         "or\t(GL)";
char p_92D7[] =	 "global\tshANON\n"
	         "call shANON";
char p_92F1[] =	 "ld (L),G0R\n"
	         "ld\t(~+2L),G1R";
char p_930A[] =	 "ld X0N,(L)\n"
	         "ld\tX1N,(~+2L)";
char p_9323[] =	 "ld L,X0N\n"
	         "ld ~+1L,X1N;XN";
char p_933B[] =	 "global\tlANON\n"
	         "call lANON";
char p_9353[] =	 "ld X0N,G10L\n"
	         "ld X1N,G11L";
char p_936B[] = {'l','d',' ','X','N',',','O','N','\n',
	         'o','r',' ','a','\n',
	         's','b','c',' ','X','N',','};
char p_9380[] =	 "GL";
char p_9383[] = {'d','e','c',' ','G','L','V','-','-','R','\n',
	         'L','\n'};
char p_9390[] =  "inc GLV--R";
char p_939B[] =  "inc GLV--R\n"
	         "L\n"
	         "dec GLV--R";
char p_93B3[] =  "global\tANlON\n"
	         "call ANlON";
char p_93CB[] =  "add L,GR\n"
	         "push\tL\n"
	         "pop XN";
char p_93E2[] =  "ld hl,0\n"
	         "ld d,l\n"
	         "ld e,GL";
char p_93F9[] =  "ld X0N,VN\n"
	         "ld X1N,V+2N";
char p_940F[] =  "global\tANON\n"
	         "call ANON";
char p_9425[] =  "global\tftol\n"
	         "call ftol";
char p_943B[] =  "ld a,h\n"
	         "xor 80h\n"
	         "ld h,a";
char p_9451[] =  "ld X0N,L\n"
	         "ld X1N,~+1L";
char p_9466[] =  "ld L,G0R\n"
	         "ld ~+1L,G1R";
char p_947B[] =  "ld L,X0N\n"
	         "ld ~+1L,X1N";
char p_9490[] =  "srAN G1L\rrr G0LV--R";
char p_94A4[] = {'l','d',' ','X','0','N',',','L','\n',
	         'l','d',' ','G','1','N',','};
char p_94B4[] =  "0";
char p_94B6[] =  "ld XN,R\n"
	         "add XN,GL";
char p_94C8[] =  "defw VL\n"
	         "defw V+2L";
char p_94DA[] =  "ld XN,GL\n"
	         "push bc";
char p_94EB[] =  "res TR&7CR,G0L\n"
	         "L";
char p_94FC[] =  "set TR&7CR,G0L\n"
	         "L";
char p_950D[] =  "or a\n"
	         "sbc GL,GR\n"
	         "L";
char p_951E[] =  "ld XN,L\n"
	         "ON LV--R";
char p_952F[] =  "ld XN,L\n"
	         "or ~+1L";
char p_953F[] =  "jp L,U0f\n"
	         "jp U1f";
char p_954F[] =  "push hl\n"
	         "push de";
char p_955F[] = {'o','r',' ','a','\n',
	         's','b','c',' ','G','L',','};
char p_956B[] =  "GR";
char p_956E[] =  "ld XN,a\n"
	         "ON a\n"
	         "L";
char p_957D[] =  "sONAN GLV--R\n"
	         "L";
char p_958C[] = {'r','e','s',' ','T','R','&','7','C','R',','};
char p_9597[] =  "G0L";
char p_959B[] =  "or a\n"
	         "sbc hl,de";
char p_95AA[] =  "ld XN,(GL+0)\n"
	         "L";
char p_95B9[] =  "set TR&7CR,G0L";
char p_95C8[] =  "push L\n"
	         "pop XN";
char p_95D6[] =  "add hl,hlV--R";
char p_95E4[] =  "push XN\n"
	         "pop L";
char p_95F2[] =  "push GR\n"
	         "pop L";
char p_9600[] = {'U','0',':','\n',
	         'j','p',' ','R','\n'};
char p_9609[] =  "U1:";
char p_960D[] =  "bit\tTR&7CR,L";
char p_961A[] =  "sONAN GLV--R";
char p_9627[] =  "dec GLV--R\n"
	         "L";
char p_9634[] =  "inc hlV--R\n"
	         "L";
char p_9641[] =  "set\tTR&7CR,L";
char p_964E[] =  "ld XN,(GL)\n"
	         "L";
char p_965B[] =  "inc GLV--R\n"
	         "L";
char p_9668[] =  "res\tTR&7CR,L";
char p_9675[] =  "dec GLV++R\n"
	         "L";
char p_9682[] =  "add GL,GR\n"
	         "L";
char p_968E[] =  "bit 7,~+3L";
char p_9699[] =  "bit 7,~+1L";
char p_96A4[] =  "jp U2f\n"
	         "U0:";
char p_96AF[] = {'l','d',' ','X','N',','};
char p_96B5[] =  "G00L";
char p_96BA[] =  "dec GLV++R";
char p_96C5[] =  "ld XN,G10L";
char p_96D0[] =  "inc LV--R";
char p_96DA[] =  "ld XN,G0L";
char p_96E4[] =  "dec LV++R";
char p_96EE[] =  "dec LV--R";
char p_96F8[] =  "ld (L),GR";
char p_9702[] =  "ld (L),XN";
char p_970C[] = {'l','d',' ','X','N',','};
char p_9712[] =  "(L)";
char p_9716[] =  "add GL,GR";
char p_9720[] =  "ld L,(R)";
char p_9729[] =  "add L,GR";
char p_9732[] =  "ld (L),R";
char p_973B[] =  "ON a,R\n"
		 "L";
char p_9744[] =  "ld XN,GL";
char p_974D[] =  "ex de,hl";
char p_9756[] =  "ld L,VR";
char p_975E[] =  "ld hl,0";
char p_9766[] = {'.','l','o','w','.'};
char p_976B[] =  "VN";
char p_976E[] =  "ld L,GR";
char p_9776[] =  "ld L,XN";
char p_977E[] =  "ld XN,L";
char p_9786[] =  "push GL";
char p_978E[] =  "push hl";
char p_9796[] =  "G00L;GL";
char p_979E[] =  "ld a,GL";
char p_97A6[] =  "G0L;GL";
char p_97AD[] =  "ld L,R";
char p_97B4[] =  "ON R\n"
	         "L";
char p_97BB[] =  "push L";
char p_97C2[] =  "defw L";
char p_97C9[] =  "ON a,R";
char p_97D0[] =  "deff L";
char p_97D7[] =  "defb L";
char p_97DE[] =  "jp L,R";
char p_97E5[] =  "X111N";
char p_97EB[] =  "or GL";
char p_97F1[] =  "indir";
char p_97F7[] =  "XN+SR";
char p_97FD[] =  "VL9f";
char p_9802[] =  "ALON";
char p_9807[] =  "cp R";
char p_980C[] =  "jp L";
char p_9811[] =  "L+VR";
char p_9816[] =  "ON R";
char p_981B[] =  "X11N";
char p_9820[] =  "sub";
char p_9824[] =  "inc";
char p_9828[] =  "add";
char p_982C[] =  "cpl";
char p_9830[] =  "neg";
char p_9834[] =  "mul";
char p_9838[] =  "and";
char p_983C[] =  "mod";
char p_9840[] =  "G1L";
char p_9844[] =  "L+0";
char p_9848[] =  "eFN";
char p_984C[] =  "L+R";
char p_9850[] = {'x'};
char p_9851[] =  "or";
char p_9854[] =  "div";
char p_9858[] =  "dec";
char p_985C[] =  "VL9";
char p_9860[] =  "lVN";
char p_9864[] =  "ZN";
char p_9867[] =  "L:";
char p_986A[] = {'n'};
char p_986B[] =  "z";
char p_986D[] =  "SN";
char p_9870[] =  "-1";
char p_9873[] =  "ge";
char p_9876[] =  "lt";
char p_9879[] =  "2";
char p_987B[] =  "4";

/* End file 2.c */


/*
 * File 3.c Created 17.05.2019 Last Modified 21.01.2021
 */

#include "stdio.h"

#define	offsetof(ty, mem)	((int)&(((ty *)0)->mem))

struct zzz {
  char		c_0;
  char		c_1;
  char		c_2;
  char		c_3;
  char		c_4;
  char		c_5;
  char 	      * p_6;
  char	      * p_8;
};

struct t {
  char  a1[ 4];  char  a2[ 5];  char  a3[ 1];  char  a4[ 2];  char  a5[ 2];
  char  a6[14];  char  a7[17];  char  a8[ 4];  char  a9[13];  char a10[20];
  char a11[ 2];  char a12[14];  char a13[26];  char a14[18];  char a15[18];
  char a16[ 1];  char a17[ 2];  char a18[16];  char a19[16];  char a20[20];
  char a21[16];  char a22[ 1];  char a23[ 3];  char a24[14];  char a25[ 2];
  char a26[ 2];  char a27[14];  char a28[14];  char a29[ 1];  char a30[ 5];
  char a31[16];  char a32[ 1];  char a33[23];  char a34[14];  char a35[16];
  char a36[14];  char a37[24];  char a38[16];  char a39[14];  char a40[16];
  char a41[ 5];  char a42[16];  char a43[16];  char a44[16];  char a45[ 1];
  char a46[ 5];  char a47[16];  char a48[16];  char a49[ 2];  char a50[ 1];
  char a51[ 1];  char a52[ 1];  char a53[ 1];  char a54[ 1];  char a55[ 1];
  char a56[ 1];  char a57[ 1];  char a58[16];  char a59[ 1];  char a60[16];
  char a61[ 4];  char a62[ 1];  char a63[16];  char a64[ 1];  char a65[ 1];
  char a66[25];  char a67[30];  char a68[25];  char a69[16];  char a70[ 2];
  char a71[15];
};

int array_987D[] = {
  offsetof(struct t,  a1), offsetof(struct t,  a1), offsetof(struct t,  a2),
  offsetof(struct t,  a3), offsetof(struct t,  a4), offsetof(struct t,  a5),
  offsetof(struct t,  a6), offsetof(struct t,  a7), offsetof(struct t,  a8),
  offsetof(struct t,  a9), offsetof(struct t, a10), offsetof(struct t, a11),
  offsetof(struct t, a12), offsetof(struct t, a13), offsetof(struct t, a14),
  offsetof(struct t, a15), offsetof(struct t, a16), offsetof(struct t, a17),
  offsetof(struct t, a18), offsetof(struct t, a19), offsetof(struct t, a20),
  offsetof(struct t, a21), offsetof(struct t, a22), offsetof(struct t, a23),
  offsetof(struct t, a24), offsetof(struct t, a25), offsetof(struct t, a26),
  offsetof(struct t, a27), offsetof(struct t, a28), offsetof(struct t, a29),
  offsetof(struct t, a30), offsetof(struct t, a31), offsetof(struct t, a32),
  offsetof(struct t, a33), offsetof(struct t, a34), offsetof(struct t, a35),
  offsetof(struct t, a36), offsetof(struct t, a37), offsetof(struct t, a38),
  offsetof(struct t, a39), offsetof(struct t, a40), offsetof(struct t, a41),
  offsetof(struct t, a42), offsetof(struct t, a43), offsetof(struct t, a44),
  offsetof(struct t, a45), offsetof(struct t, a46), offsetof(struct t, a47),
  offsetof(struct t, a48), offsetof(struct t, a49), offsetof(struct t, a50),
  offsetof(struct t, a51), offsetof(struct t, a52), offsetof(struct t, a53),
  offsetof(struct t, a54), offsetof(struct t, a55), offsetof(struct t, a56),
  offsetof(struct t, a57), offsetof(struct t, a58), offsetof(struct t, a59),
  offsetof(struct t, a60), offsetof(struct t, a61), offsetof(struct t, a62),
  offsetof(struct t, a63), offsetof(struct t, a64), offsetof(struct t, a65),
  offsetof(struct t, a66), offsetof(struct t, a67), offsetof(struct t, a68),
  offsetof(struct t, a69), offsetof(struct t, a70), offsetof(struct t, a71)
};

struct t array_990D = {
  { 0x51, 0x68, 0x69,    0 },		/*  a1[ 4] = "Qhi"		*/
  { 0x50, 0x51, 0x68, 0x69,    0 },	/*  a2[ 5] = "PQhi"		*/
  {    0 },				/*  a3[ 1] = ""			*/
  { 0x48,    0 },			/*  a4[ 2] = "H"		*/
  { 0x48,    0 },			/*  a4[ 2] = "H"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x5A,	/*  a6[14] = "HNSTZ]^_djprs"	*/
    0x5D, 0x5E, 0x5F, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/*  a7[17] = "HNSTUVZ]^_dgjprs" */
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x67, 0x6A, 0x70, 0x72,
    0x73,    0 },
  { 0x51, 0x68, 0x69,    0 },		/*  a8[ 4] = "Qhi"		*/
  { 0x48, 0x4E, 0x54, 0x59, 0x5A,	/*  a9[13] = "HNTYZ]^djprs"	*/
    0x5D, 0x5E, 0x64, 0x6A, 0x70,
    0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x52, 0x53, 0x54,	/* a10[20] = "HNRSTUVZ[]^_`djnprs" */
    0x55, 0x56, 0x5A, 0x5B, 0x5D,
    0x5E, 0x5F, 0x60, 0x64, 0x6A,
    0x6E, 0x70, 0x72, 0x73,    0 },
  { 0x48,    0 },			/* a11[ 2] = "H"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x5A,	/* a12[14] = "HNSTZ]^_djprs"	*/
    0x5D, 0x5E, 0x5F, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x48, 0x49, 0x4D, 0x4E, 0x52,	/* a13[26] = "HIMNRSTUVZ[\\]^_\\abcdfjprs" */
    0x53, 0x54, 0x55, 0x56, 0x5A,
    0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
    0x60, 0x61, 0x62, 0x63, 0x64,
    0x66, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a14[18] = "HNSTUVYZ]^_djprsw" */
    0x56, 0x59, 0x5A, 0x5D, 0x5E,
    0x5F, 0x64, 0x6A, 0x70, 0x72,
    0x73, 0x77,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a15[18] = "HNSTUVZ]^_djklprs" */
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x6B, 0x6C, 0x70,
    0x72, 0x73,    0 },
  {    0 },				/* a16[ 1] = ""			*/
  { 0x4E,    0 },			/* a17[ 2] = "N"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a18[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a19[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x52, 0x53, 0x54,	/* a20[20] = "HNRSTUVYZ[]^_`djprs" */
    0x55, 0x56, 0x59, 0x5A, 0x5B,
    0x5D, 0x5E, 0x5F, 0x60, 0x64,
    0x6A, 0x70, 0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a21[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  {    0 },				/* a22[ 1] = ""			*/
  { 0x4E, 0x74,    0 },			/* a23[ 3] = "Nt"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x5A,	/* a24[14] = "HNSTZ]^_djprs"	*/
    0x5D, 0x5E, 0x5F, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x6D,    0 },			/* a25[ 2] = "m"		*/
  { 0x48,    0 },			/* a26[ 2] = "H"		*/
  { 0x48, 0x4E, 0x4F, 0x54, 0x59,	/* a27[14] = "HNOTYZ]^djprs"	*/
    0x5A, 0x5D, 0x5E, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x54, 0x55, 0x56,	/* a28[14] = "HNTUVZ]^djprs"	*/
    0x5A, 0x5D, 0x5E, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  {    0 },				/* a29[ 1] = ""			*/
  { 0x50, 0x51, 0x68, 0x69,    0 },	/* a30[ 5] = "PQhi"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a31[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  {    0 },				/* a32[ 1] = ""			*/
  { 0x48, 0x4E, 0x52, 0x53, 0x54,	/* a33[23] = "HNRSTUVWZ[]^_`cdfjprsw" */
    0x55, 0x56, 0x57, 0x5A, 0x5B,
    0x5D, 0x5E, 0x5F, 0x60, 0x63,
    0x64, 0x66, 0x6A, 0x70, 0x72,
    0x73, 0x77,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x5A,	/* a34[14] = "HNSTZ]^_djprs"	*/
    0x5D, 0x5E, 0x5F, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a35[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x5A,	/* a36[14] = "HNSTZ]^_djprs"	*/
    0x5D, 0x5E, 0x5F, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x48, 0x49, 0x4E, 0x53, 0x54,	/* a37[24] = "HINSTUVWZ]^_abcdfjprsvw" */
    0x55, 0x56, 0x57, 0x5A, 0x5D,
    0x5E, 0x5F, 0x61, 0x62, 0x63,
    0x64, 0x66, 0x6A, 0x70, 0x72,
    0x73, 0x76, 0x77,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a38[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x5A,	/* a39[14] = "HNSTZ]^_djprs"	*/
    0x5D, 0x5E, 0x5F, 0x64, 0x6A,
    0x70, 0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a40[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x50, 0x51, 0x68, 0x69,    0 },	/* a41[ 5] = "PQhi"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a42[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a43[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a44[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  {    0 },				/* a45[ 1] = ""			*/
  { 0x50, 0x51, 0x68, 0x69,    0 },	/* a46[ 5] = "PQhi"		*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a47[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a48[16]="HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x48,    0 },			/* a49[ 2] = "H"		*/
  {    0 },				/* a50[ 1] = ""			*/				
  {    0 },				/* a51[ 1] = ""			*/
  {    0 },				/* a52[ 1] = ""			*/
  {    0 },				/* a53[ 1] = ""			*/
  {    0 },				/* a54[ 1] = ""			*/
  {    0 },				/* a55[ 1] = ""			*/
  {    0 },				/* a56[ 1] = ""			*/
  {    0 },				/* a57[ 1] = ""			*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a58[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  {    0 },				/* a59[ 1] = ""			*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a60[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  { 0x51, 0x68, 0x69,    0 },		/* a61[ 4] = "Qhi"		*/
  {    0 },				/* a62[ 1] = ""			*/
  { 0x48, 0x4E, 0x53, 0x54, 0x55,	/* a63[16] = "HNSTUVZ]^_djprs"	*/
    0x56, 0x5A, 0x5D, 0x5E, 0x5F,
    0x64, 0x6A, 0x70, 0x72, 0x73,
       0 },
  {    0 },				/* a64[ 1] = ""			*/
  {    0 },				/* a65[ 1] = ""			*/
  { 0x48, 0x4D, 0x4E, 0x4F, 0x52,	/* a66[25] = "HMNORSTUVZ[\\]^_`acdfjprs" */
    0x53, 0x54, 0x55, 0x56, 0x5A,
    0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
    0x60, 0x61, 0x63, 0x64, 0x66,
    0x6A, 0x70, 0x72, 0x73,    0 },
  { 0x48, 0x49, 0x4A, 0x4B, 0x4C,	/* a67[30] = "HIJKLNOSTUVYZ]^_abcdfjopqrsux" */
    0x4E, 0x4F, 0x53, 0x54, 0x55,
    0x56, 0x59, 0x5A, 0x5D, 0x5E,
    0x5F, 0x61, 0x62, 0x63, 0x64,
    0x66, 0x6A, 0x6F, 0x70, 0x71,
    0x72, 0x73, 0x75, 0x78,    0 },
  { 0x48, 0x4D, 0x4E, 0x52, 0x53,	/* a68[25] = "HMNRSTUVXZ[\\]^_`acdfjprs" */
    0x54, 0x55, 0x56, 0x58, 0x5A,
    0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
    0x60, 0x61, 0x63, 0x64, 0x66,
    0x6A, 0x70, 0x72, 0x73,    0 },
  { 0x48, 0x4E, 0x54, 0x57, 0x5A,	/* a69[16] = "HNTWZ]^cdfjprsw"	*/
    0x5D, 0x5E, 0x63, 0x64, 0x66,
    0x6A, 0x70, 0x72, 0x73, 0x77,
       0 },
  { 0x48,    0 },			/* a70[ 2] = "H"		*/
  { 0x48, 0x4E, 0x54, 0x5A, 0x5D,	/* a71[15] = "HNTZ]^cdefjprs"	*/
    0x5E, 0x63, 0x64, 0x65, 0x66,
    0x6A, 0x70, 0x72, 0x73,    0 },
};

int  array_9BD4[] = {
  -66,  -65,  -68,    0,   89,  -69,  -65,  -68,    0,    0,
    1,    0,   -8,    0,    3,   62, -221,  141, -167,  231,
  251, -151,  264,  -70, -106,  276, -100,    0,    5,   64,
 -221,  141,  -90,  163,  170,  234,  251, -151,  264,  -63,
  -70,  274,  278, -100,    0,  -64,  -65,  -68,    0,  -28,
  -47,  141,  -33,  172,  239,  251,  264,  -70, -106, -102,
 -100,    0,    8,   68, -245, -215,  141,  -84,  163,  174,
 -250,  234,  251, -151, -243,  264,  -70,  -98,  274,  278,
 -100,    0,   13,    0,    3,   62, -221,  141, -167,  231,
  251, -151,  264,  -70, -106,  276, -100,    0,    9,   58,
  
   60,   68,  116,  118,  141,  143,  163,  176,  229, -111,
  241,  251, -151,  253,  255,  257,  259,  264,  266,  -70,
  274,  278, -100,    0,    5,   64,  121,  141,  -89,  163,
  -36,  182,  234,  251, -151,  264,  -70,  274,  278, -100,
  283,    0,   18,   64, -220,  141,  147,  163,  187,  234,
  251, -151,  264,  -70, -141, -137,  274,  278, -100,    0,
    0,  -49,    0,    5,   64, -221,  141,  -90,  163, -197,
  234,  251, -151,  264,  -70,  274,  278, -100,    0,   23,
   64, -220,  141,  147,  163,  189,  234,  251, -151,  264,
  -70,  274,  278, -100,    0,    9,   68, -245,  123,  141,
  
  149,  163,  -35,  191, -251,  234,  251, -151, -243,  264,
  -70,  274,  278, -100,    0,    5,   64,  132,  141,  -96,
  163, -202,  234,  251, -151,  264,  -70,  274,  278, -100,
    0,    0,  -50, -114,    0,    3,   62, -221,  141, -167,
  231,  251, -151,  264,  -70, -106,  276, -100,    0,  -99,
    0,  -16,    0,  -28,  -47, -148,  141,  -32, -161,  239,
  251,  264,  -70, -106, -102, -100,    0,   27,   73,  141,
  -74,  163, -164,  247,  251,  264,  -70,  274,  279, -100,
    0,    0,  102,  -69,  -65,  -68,    0,    5,   64, -223,
  141,  155,  163,  200,  234,  251, -151,  264,  -70,  274,
  
  278, -100,    0,    0,   30,   76, -245,  134,  141,  157,
  163,  165,  202, -247,  234,  251, -151, -243,  -54,  264,
  269,  -70,  274,  278, -100, -139,    0,    3,   62, -219,
  141, -166,  231,  251, -151,  264,  -70, -106,  276, -100,
    0,   38,   64, -219,  141,  -92,  163,  209,  234,  251,
 -151,  264,  -70,  274,  278, -100,    0,    3,   62, -219,
  141, -166,  231,  251, -151,  264,  -70, -106,  276, -100,
    0,   42, -238,   82,  137,  141,  159,  163,  168,  211,
  241,  251, -151,  -51, -152,  262,  264,  271,  -70,  274,
  278, -100,  281, -139,    0,   23,   64, -219,  141,  -92,
  
  163,  217,  234,  251, -151,  264,  -70,  274,  278, -100,
    0,    3,   62, -219,  141, -166,  231,  251, -151,  264,
  -70, -106,  276, -100,    0,    5,   64, -222,  141,  161,
  163, -170,  234,  251, -151,  264,  -70,  274,  278, -100,
    0,   89,  -69,  -65,  -68,    0,    5,   64, -222,  141,
  161,  163, -170,  234,  251, -151,  264,  -70,  274,  278,
 -100,    0,    5,   64, -219,  141,  -92,  163, -179,  234,
  251, -151,  264,  -70,  274,  278, -100,    0,   48,   64,
 -219,  141,  -92,  163,  219,  234,  251, -151,  264,  -70,
  274,  278, -100,    0,    0,  109,  -69,  -65,  -68,    0,
  
    5,   64, -223,  141,  155,  163,  221,  234,  251, -151,
  264,  -70,  274,  278, -100,    0,    5,   64, -216,  141,
  -76,  163, -160,  234,  251, -151,  264,  -70,  274,  278,
 -100,    0,   52,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    5,   64, -221,  141,  -90,  163, -178,  234,
  251, -151,  264,  -70,  274,  278, -100,    0,    0,    5,
   64, -221,  141,  -90,  163,  223,  234,  251, -151,  264,
  -70,  274,  278, -100,    0,  -67,  -65,  -68,    0,    0,
    5,   64, -227,  141,  -95,  163, -202,  234,  251, -151,
  264,  -70,  274,  278, -100,    0,    0,    0,    9, -133,
  
   68, -149, -245, -212,  141,  -97,  163,  225, -248, -112,
  234,  251, -151, -243,  -52,  -53,  264,  -61,  -70,  274,
  278, -100,    0,    5, -237, -104, -252, -242,   64, -150,
  139,  141,  -73,  163,  -34,  227,  241,  251, -151,  -51,
 -152,  -55,  264,  272,  -70, -241,  274, -155,  278, -100,
 -253, -154,    0,    9, -133,   68, -245, -212,  141,  -97,
  163, -115,  225, -248, -113,  234,  251, -151, -243,  -52,
  -53,  264,  -61,  -70,  274,  278, -100,    0,   56,   87,
  141, -142, -165,  239,  251,  -54,  264,  269,  -70, -106,
 -102, -100, -139,    0,  -18,    0,  -28,  -47,  141, -158,
 
  239,  251,  -57,  264,  -62,  -61,  -70, -106, -102, -100,
    0
};

int array_A162[] = {
    0,    9,  -10,   25,  -28,   21,   25,  -28,    7,   21,
   25,   28,  -29,   11,   12,   13,   14,  -15,    4,    5,
   21,   25,  -28,    6,   21,   25,  -28,    1,   21,  -28,
   17,   20,   21,   22,   25,   26,   28,  -29,    3,   21,
   25,  -28,    4,    5,   20,   21,   25,  -28,    2,   21,
   25,  -28,   19,   23,   24,  -27,   20,  -28,  239, -240,
  133, -134,   46,  -47,   43,   44,   46,  -47,   43,   44,
   46,   47,  -48,   43,   44,  -47,   43,   44,   45,   46,
   47,  -48,   43,   44,   45,   46,  -47,   45,  -47,  116,
  117,  118,  119,  120,  121,  122,  123,  124,  127,  130,
  
  131, -132,  117,  118,  120,  125,  128,  131, -132,  117,
  118,  120,  126,  129,  131, -132,  245, -246,  212,  214,
 -217,  218, -221,  228,  229,  230,  231,  232,  233,  234,
  235, -236,  211, -227,  224,  225, -226,  214, -219,  213,
 -214,  135, -136,   71,   72,   73,  -97,   93,  -94,   77,
   78,   79,   80,   81,  -82,   85,  -86,   75,  -83,   73,
  -91,   87,  -88,   30,  -31,  145,  146, -147,  143, -144,
  175, -178,  161, -207,  185, -204,  162,  163,  182,  183,
  184, -185,  161,  198,  199,  200, -201,  173, -180,  172,
 -181,  161,  185,  186,  187,  205,  206,  208,  209, -210,
 
  169, -171,  159,  165,  185,  194,  195,  196, -203,  174,
 -179,  163,  165,  188,  189,  191, -193,  190, -192,  176,
 -179,  168, -171,  177, -178,  162, -185,  161, -163,  248,
 -249,   40,   41,  -42,   38,   39,   40,   41,  -42,   40,
  -41,   37,   38,   39,   40,   41,  -42,   38,   39,   40,
  -41,  109, -110,  243, -244,   51,  -52,  152, -153,   53,
   55,  -56,   54,  -55,  107, -108,   59,   60,  -61,   58,
  -61,   58,   59,  -61,  105, -106,  101, -102,  101,  102,
 -103,  156, -157,  138, -140
};

/* End file 3.c */


/*
 * File -  sub_13D.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_13D v0				Used in: sub_1F4B
 *********************************************************
int sub_13D(int a, int b) {
    int c;

    c = array_987D[b];
    goto m2;
m1: c++;
m2: if(array_990D[c] != 0) goto m3;
m3: if((uchar)array_990D[c] != a) goto m5;
    goto m4;
m4: goto m7;
m5: goto m6;
m6: goto m1;
m7: array_9BD4[c];
    goto m8;
m8: return;
}
*/

/*********************************************************
 * sub_13D v1 				Used in: sub_1F4B
 *********************************************************
int sub_13D(int a, int b) {
    int c;

    c = array_987D[b];
    goto m2;
m1: c++;
m2: if(array_990D[c] == 0) goto m7;
m3: if((uchar)array_990D[c] != a) goto m1;
m7: return array_9BD4[c];
}
*/

/*********************************************************
 * sub_13D v2 				Used in: sub_1F4B
 *********************************************************
int sub_13D(int a, int b) {
    int c;

m1: for(c = array_987D[b]; ; c++) {
m2:	if(array_990D[c] == 0) break;
m3:	if(array_990D[c] == a) break;
    }
m7: return array_9BD4[c];
}
*/

/*********************************************************
 * sub_13D v3 OK++			Used in: sub_1F4B
 *
 * This version is closest to binary code.
 * It does not create unnecessary unconditional jumps
 *********************************************************/
int sub_13D(int a, int b) {
    unsigned int c;

    for(c = array_987D[b];(array_990D[c] == 0)||((unsigned)array_990D[c] == a); c++)
      ;
#ifdef DEBUG
    printf("\tsub_13D(%d, %d)\tReturn %d\n", a, b, array_9BD4[c]);
#endif
    return array_9BD4[c];

}

/* End of file -  sub_13D.c */


/*
 * File - sub_1B2.c Created 09.03.2019 Last Modified 21.01.2021
 */

#include "stdio.h"
#include <string.h>

#include "cgen.h"

/*********************************************************
 * char sub_1B2 OK++	       Used in: sub_6D1, sub_4192
 *
 * Token search		(Binary search algorithm is used)
 *********************************************************/
char sub_1B2(register char * target) {
    unsigned char hi, lo, mid;
    char midVal;

    static char * tnames[] = {
    "",    "!",  "!=",  "#",  "$",  "$U", "%",  "&",  "&&", "&U",		
    "(",   ")",  "*",   "*U", "+",  "++", "+U", ",",  "-",  "--",		
    "->",  "-U", ".",   "..", "/",  ":",  ":U", ":s", ";",  ";;",		
    "<",   "<<", "<=",  "=",  "=%", "=&", "=*", "=+", "=-", "=/",		
    "=<<", "==", "=>>", "=^", "=|", ">",  ">=", ">>", "?",  "@",		
    "[\\", "[a", "[c",  "[e", "[i", "[s", "[u", "[v", "^",  "{",		
    "|",   "||", "}",   "~", "RECIP", "TYPE", "ID", "CONST",	
    "FCONST", "REG", "INAREG", "BITFIELD" };

    static char byte_A46A = 65;

#ifdef DEBUG
        printf("\tsub_1B2(\"%s\")\t", target);
#endif

    lo = 0;
    hi = byte_A46A;
    do {
      mid = (hi + lo)/2;
      if((midVal = strcmp(target, tnames[mid])) == 0) {
#ifdef DEBUG
        printf("\tReturn = %d\n", mid);
#endif
        return mid; 
      }
      if(midVal < 0) hi = mid - 1;
      else           lo = mid + 1;
    } while(hi >= lo);
    return (-1); /* Search terminates as unsuccessful */
}

/*********************************************************
 * gethashptr OK++		Used in: sub_265, sub_1754
 *
 * Convert name to a hash table ptr (sub_21F)
 *
 * Returns pointer to pointer to structure associated with
 * pointer to token.  for example
 *
 * Input	Hash key  Destination
 * string  	dec hex
 *   "f"  	 1	- float
 *   "i"  	 4	- int
 *   "l"  	 7	- long
 *   "s"  	14 0eh	- short
 *   "v"  	17 11h	- void
 *   "x"  	19 13h	- x ?
 *   "uc" 	30 1eh	- unsigned char
 *   "ui" 	36 24h	- unsigned int
 *   "ul" 	39 27h	- unsigned long
 *   "us" 	46 2eh	- unsigned short
 *   "ux" 	51 33h	- unsigned ?
 *   "b"  	98 62h	- b ?
 *   "c"  	99 63h	- char
 **********************************************************/

#define HASHTABSIZE (unsigned)0x65

struct bbb ** gethashptr(register char * sname) {
    unsigned int key;

#ifdef DEBUG
    printf("\tgethashptr(%s)\n", sname);
#endif

    key = 0;
    while((uchar)*sname != 0) {
      key = key*2 + (uchar)*sname; /* Get numeric value of key */
      sname++;
    }
    /* Hash table index is determined by    */
    /* hash function using division method  */
    return &hashtab[key%HASHTABSIZE];
}

/*********************************************************
 * sub_265 OK++	     Used in: sub_627,  sub_B19,  sub_E43,
 *			      sub_1680, sub_1754, sub_4192
 *
 * Return pointer to struct associated with pointer to token
 *********************************************************/
struct bbb * sub_265(char * str) { 
    struct bbb		 ** l1b;
    register struct bbb   * sb;

#ifdef DEBUG
    printf("\tsub_265(%s)\n", str);
#endif
					  /* In hash table, we look for pointer to    */
    l1b = gethashptr(str);		  /* entry in symbol table associated with    */
    sb  = *l1b;				  /* specific name. 			      */
    while(sb != 0) {			  /* While record is not the last in list,    */
    					  /* we check whether its name is correlated  */
      if(strcmp(sb->b_name, str) == 0) {  /* with a specific one.		      */
#ifdef DEBUG
        printf("\tsub_265\t\t\tReturn %x\n", sb);
#endif
        return sb;			  /* If such entry exists, return pointer to  */
     }					  /* it. Otherwise,			      */
      sb = sb->b_next;			  /* we check record associated with it.      */
    }					  /* If record does not exist,		      */
    sb = allocmem(sizeof(struct bbb));	  /* create new record. As record associated  */
    sb->b_next = *l1b;			  /* with it, we save pointer found in hash   */
					  /* table.				      */
    sb->b_name = allocmem(strlen(str)+1); /* We allocate place under name and	      */
    strcpy(sb->b_name, str);		  /* give her a specific name; 		      */
    sb->b_ndpth = nstdpth;		  /* correlate it with current nesting depth; */
    *l1b     = sb;			  /* save pointer to it at current hash table */
/*
    if(++symcnt > dynmem) dynmem = symcnt;
*/
#ifdef DEBUG
    printf("\tsub_265\t\t\tReturn %x\n", sb);
#endif
    return sb;				  /* position and return pointer to record.   */
}

/* End of file -  sub_1B2.c */


/*
 * File - sub_306.c Created 09.03.2019 Last Modified 11.05.2020
 */
 
#include "stdio.h"
#include <stdlib.h>
#include <ctype.h>
#include "cgen.h"

/*********************************************************
 * sub_306 v1 OK+    Used in: sub_6D1,  sub_793,  sub_B19,
 *			      sub_E43,  sub_17E0, sub_19C1,
 *			      sub_4192
 * get_token	     No code matching
 *********************************************************/
char * sub_306() {
    int ch, mark;
    register char * ptr;

#ifdef DEBUG
    printf("\tsub_306()");
#endif
	
    mark = 0;
    for(;;) {
      ptr = buffer;

/*    do {
	if((ch = getchar()) == EOF) break;
      } while((isspace(ch)) != 0);
      if(ch == EOF) return (-1);
*/
      do {
	if((ch = getchar()) == EOF)
	return (char *)EOF;		/* Read characters until	*/
      } while(isspace(ch) != 0);	/* detection of white-space	*/

      *(ptr++) = ch;			/* Put character in buffer	*/
      do {
	*(ptr++) = ch = getchar();
	if(ch == EOF) break;		/* Get and put in buffer 	*/
      } while(isspace(ch) == 0);	/*  white-space character	*/

      ptr += (-1); 			/* Put 0 in the place 	 	*/
      *ptr = 0;				/* of the last character 	*/
    
      if(*buffer == '"') {		/* If 1 character in buffer 	*/
	lineno = atoi(buffer+1);	/* is '"' assign lineno value  	*/
	mark=(ch != '\n') ? 1 : 0;	/* If detected newline set mark */
	continue;			/* Parse next line 		*/
      }
      if (mark != 0) {			/* If '\n' is not encountered 	*/
					/* copy program name to buffer 	*/
	strncpy(progname, buffer, sizeof(progname)-1);
	mark = 0;			/* clear mark and		*/
	continue;			/* parse next line 		*/
      }
      if(*buffer != ';' 		/* If 1 or 2 character of  	*/
      || *(buffer+1) != ';') {		/* buffer contains ';' 		*/
#ifdef DEBUG
        printf("\t\tReturn \"%s\"\n", buffer);
#endif
        return buffer;			/* return buffer addr		*/
      }
      do {
	ch = getchar();			/* Read and  			*/
	putchar(ch);			/* print characters 		*/
      } while (ch != '\n');		/* not yet detected newline 	*/
    } 					/* Parse next line 		*/
}

/* End of file sub_306.c */


/*
 * File - sub_406.c Created 09.03.2019 Last Modified 09.12.2020
 */

#include "stdio.h"
#include <ctype.h>
#include "cgen.h"

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

/*********************************************************
 * sub_406 v3 OK++			 Used in: sub_6D1
 *
 * Note:
 *   Added "empty" parameter to sub_5CF5 function call to
 *   match number and types actual and formal parameters
 *   this function.
 *   sub_5CF5 function is called only if value sb->b_c13
 *   is 3 or 4. if this condition is met, variable "empty"
 *   in sub_5CF5 function is not used.
 *********************************************************/
void sub_406() {
  struct bbb	     ** l1b;
  int			l2;
  struct bbb	      * l3b;
  struct bbb	      * l4b;
  struct ptr	      * l5;
  int			l6;
  register struct bbb * sb;

#ifdef DEBUG
  printf("\tsub_406()\n");
#endif

  l2  = ARRAY_SIZE(hashtab);
  l1b = hashtab;
  do {
    l3b = 0;							/* m1: 	*/
    sb  = *l1b;
    while((sb != 0) && ((uchar)sb->b_ndpth == nstdpth)) {
      if(sb->b_class == DECL9) {	/* '9' */		/* m3: 	*/
	if(sb->b_c13 == 2)
	  word_B017 |= array_AAE8[(int)sb->b_memb];		/* m4: 	*/
	if((sb->b_c13 == 4) || (sb->b_c13 == 3))
	  sub_5CF5(sb, empty); /* Add parameter "empty"! */	/* m12: */
	if(0 < nstdpth) {					/* m6: 	*/
	  if(sb->b_c13 == 3) {
	    l4b        = sb->b_next;
	    sb->b_next = l3b;
	    l3b        = sb;
	    (sb->b_ndpth)--;
	    sb         = l4b;
	    continue;
	  }
	}
      }

      sub_7028(((struct ptr *)sb)->next_ptr);	 		/* m7:	*/

      if((sb->b_class == UDECL) || (sb->b_class == SDECL)) {
	l6 = *(sb->b_memb);					/* m8:  */

	l5 = (struct ptr *)(sb->b_memb + 1);

	while(l6-- != 0)					/* m10: */
	  sub_7028((l5++)->next_ptr);
	
	sub_7028((struct ptr *)sb->b_memb);
      }
      sub_7028((struct ptr *)sb);				/* m11: */
      sb = sb->b_next;
    }
    if(l3b != 0) {						/* m13: */
      *(l1b++) = l3b;
      while(l3b->b_next != 0) {					/* m15: */
        l3b = l3b->b_next;					/* m14: */
      }
      l3b->b_next = sb;
    } else {
      *(l1b++)  = sb;						/* m16: */
    }
  } while((--l2) != 0);						/* m17: */

  nstdpth--;
  if(lvlidx >= 0) {
    if(array_AE57[lvlidx] == nstdpth) {
      sb = array_AEDB[lvlidx];
      if(sb->b_type->b_class == SDECL) {
	if((sb->b_refl & 4) == 0) {
	  sub_BEE(sb->b_i11, sb->b_size);
	}
      }
      sub_BCC(sb->b_i11, array_AE13[lvlidx]);			/* m18: */
      lvlidx--;
      word_B017 = 0x17F;
    }
  }
#ifdef DEBUG
  printf("\tsub_406 Exit\n");
#endif

}

/*********************************************************
 * sub_627 OK++     Used in: sub_17E0, sub_19C1, sub_4192
 *********************************************************/
struct bbb * sub_627(register char * ch, unsigned * par) { 
    unsigned loc;

#ifdef DEBUG
    struct bbb * tmp;
    printf("\tsub_627(\"%s\", %x)\n", ch, par);
#endif

    loc = 0;
    ch++;
    do {
      loc <<= 2;
      if(*ch == '(') {
	loc |= 2;
	ch++;
      } else if(*ch == '*') {
	loc |= 1;
	ch++;
      }
    } while ((isalnum(*ch) == 0) && (*ch != '_'));
    *par = 0;
    while (loc != 0) {
      *par <<= 2;
      *par |= (loc & 3);
      loc >>= 2;
    }
#ifdef DEBUG
    tmp = sub_265(ch);
    printf("\tsub_627\t\t\tReturn %x\n", tmp);
    return tmp;
#else
    return sub_265(ch);
#endif
}	

/*********************************************************
 * sub_6C8 OK++			Used in: sub_6D1, sub_76F
 *********************************************************/
void sub_6C8(void) {

    faterror("Bad int. code");
}

/* End of file sub_406.c */


/*
 * File - sub_6D1.c Created 09.03.2019 Last Modified 26.05.2020
 */
 
#include "stdio.h"
#include "cgen.h"

enum psect {
  P_BSS = 1,
  P_TEXT,
  P_DATA
};

/*********************************************************
 * sub_6D1 OK+				    Used in: main
 *
 * Compiling intermediate code
 *
 * Note:
 * Compiler generates identical code from restored source
 * program in C, however, location of branches associated
 * with case constants is different from original.
 * This does not affect the function.
 *********************************************************/
void sub_6D1(void) {
    register char * ch;
    int tok;

#ifdef DEBUG
    printf("\n\tsub_6D1 - Compiling_intermediate_code()\n\n");
#endif

    word_B017 = 0x17F;
    while((ch = sub_306()) != (char *)EOF) { /* get_token    */

#ifdef DEBUG
      tok = sub_1B2(ch);
      printf("\tsub_6D1\t\t\ttok = %x tok-50 = %x\n", tok, tok-50);
      switch (tok-50) {
#else
      switch ((tok = sub_1B2(ch))-50) {	     /* search_token */
#endif
	case 0:		/* "[\\" - case		*/
	  sub_E43();
	  break;
	case 1:		/* "[a" 		*/
	  sub_793();
	  break;
	case 2:		/* "[c" enum		*/
	  sub_1B0C();
	  break;
	case 3:		/* "[e" expression	*/
	  selpsect(P_TEXT);
	  sub_3DC9(sub_4192());
	  sub_76F(']');
	  break;
	case 4:		/* "[i" initialization	*/
	  sub_B19();
	  break;
	case 5:		/* "[s" struct		*/
	case 6:		/* "[u" union		*/
	  sub_19C1(tok);
	  break;
	case 7:		/* "[v" variable	*/
	  sub_17E0();
	  break;
	case 9:		/* "{" opening block 	*/
	  nstdpth++;		/* Increase the current nesting depth */
	  break;
	case 12:	/* "}" end of block 	*/
	  sub_406();
	  break;
	case 8:		/* "^" 			*/
	case 10:	/* "|" 			*/
	case 11:	/* "||" 		*/
	default:
	  sub_6C8();		/* {faterror("Bad int. code");} */ 
      }
    }
    sub_406();
}	

/* End of file sub_6D1.c */


/*
 * File - sub_76F.c  Created 09.03.2019 Last Modified 26.05.2020
 */

#include "stdio.h"
#include <ctype.h>
#include "cgen.h"

enum psect {
  P_BSS = 1,
  P_TEXT,
  P_DATA
};

/*********************************************************
 * sub_76F OK++	      Used in: sub_6D1,  sub_B19, sub_E43,
 * 			       sub_17E0, sub_1B0C 
 ;
 * Search for expected character (closing square bracket)
 *********************************************************/
void sub_76F(int par) {
    char ch;

#ifdef DEBUG
    printf("\tsub_76F()\n");
#endif

    do {
      ch = getchar();
    } while (isspace(ch));	/* Skip white-space characters */

    if(ch != (char)par) {
      sub_6C8(); 		/* {faterror("Bad int. code");} */
    }
}

/*********************************************************
 * sub_793 OK++ 			 Used in: sub_6D1
 *********************************************************/
void sub_793(void) {
    char	  * loc1;
    char	    buf[1024];
    register char * ptr;

#ifdef DEBUG
    printf("\tsub_793()\n");
#endif

    selpsect(P_DATA);
    sub_2BD0(sub_600E(sub_43EF(COLON_U, sub_43EF(COLON_S, sub_4192(), 0), 0)));
    ptr = buf;
    for(;;) {
      loc1 = sub_306();		/* Get_token */
      if(*loc1 == ']') break;	/* If data is over go to its output */
      *ptr = atoi(loc1);	/* Convert string to int value and place it in buffer */
      ptr++;			/* Set next address  */
    }				/* and continue processing */
    sub_155D(buf, ptr-buf); 	/* Emit data "defb byte1, ..." ("ptr-buf" bytes from "buf")*/
}

/* End of file sub_76F.c  */


/*
 * File - sub_808.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_808 OK+				 Used in: sub_B19
 *
 * Generated code is completely identical, except for
 * incomprehensible code inside function that does not
 * affect program logic
 *********************************************************/
int sub_808(register struct bbb * sb, struct aaa * p2a) {
    int		 l1;
    int		 l2;
    struct bbb * l3b;
    struct bbb * l4b;
    int	     	 l5;
    struct aaa * l6a;

#ifdef DEBUG
    printf("\tsub_808(%x, %x)\n", sb, p2a);
#endif

    l1 = 0;
    if(p2a->a_c0 != COLON_U) goto m12;
    sub_475C(p2a);
    l5 = 0;
    if(sb->b_class == SDECL) {
      l3b = sb;
      while((p2a = sub_4192())->a_c0 != DOT_DOT) {	/* m7:  */
        /* assigning to "struct bbb *" from "int"          v	*/
        if((l2 = sub_1CC4((l4b = *(l3b->b_memb + (l5++) + 1)))) != 0) { /* m1:  */
          if(l1%(++l2) != 0) {
            l2 = l2 - l1%l2;
            l1 = l1 + l2;
            sub_CDF(l2); /* Emit "defb 0, ..." (l2 bytes) */
          }
        }
        if((l4b->b_c3 & 0x10) != 0) {			/* m2:  */
          p2a = sub_43EF(BAND, p2a, sub_415E(((long)1<<(l4b->b_i5))+(long)(-1)));
          if(HI_CHAR(l4b->b_i5) != 0) {
            /* At this point in file CGEN.COM there is a small	*/
            /* fragment directly unused code 5 bytes long	*/
            l6a = sub_43EF(BOR, l6a, sub_43EF(LSHIFT, p2a, sub_415E(0)));
          } else {
            l6a = p2a;					/* m3: */
          }
          if(l5 != *(l3b->b_memb)) {			/* m4:  */
            if((char)(((struct bbb *)*(l5 + l3b->b_memb + 1))->b_c3 & 0x10) != 0) {	/* cast to "struct bbb *" from smaller integer type "int" */
              if(((struct bbb *)*(l5 + l3b->b_memb + 1))->b_i11 == l4b->b_i11) continue;	/* cast to "struct bbb *" from smaller integer type "int" */
            }
          }
          p2a = l6a;
        }						/* m5:  */
        l1 += sub_808(l4b, p2a);			/* m6:  */
      }
m8:   sub_475C(p2a);
    } else {
      l3b = sb->b_type;					/* m9:  */
      for(;;) {
        for(;;) {
          p2a = sub_4192();				/* m10: */
          if(p2a->a_c0 != COLON_U) break;
          l1 += sub_808(l3b, p2a);
        }
        if(p2a->a_c0 == DOT_DOT) goto m8;		/* m11: */
        l1 += nodesize(p2a);
        sub_2BD0(sub_600E(sub_43EF(ATGIGN, p2a, 0)));
      }
m12:  p2a = sub_600E(sub_43EF(ATGIGN, p2a, 0));		/* m12: */
      l1  = nodesize(p2a);
      sub_2BD0(p2a);
    }
    if(l1 < sb->b_size) {				/* m13: */
      sub_CDF(sb->b_size - l1);
      l1 = sb->b_size;
    } else {
      if((sb->b_size < l1) && (sb->b_size != 0))	/* m14: */
        uerror("Too many initializers");
    }
#ifdef DEBUG
    printf("\tsub_808 Return %x\n", l1);
#endif
    return l1;						/* m15: */
}

/* End of file - sub_808.c  */


/*
 * File - sub_B19.c Created 09.03.2019 Last Modified 21.01.2021
 */

#include "stdio.h"
#include <stdlib.h>
#include "cgen.h"

enum psect {
  P_BSS = 1,
  P_TEXT,
  P_DATA
};

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_B19 OK++				 Used in: sub_6D1
 *********************************************************/
void sub_B19(void) {
    register struct bbb * sb;
    int l1;
    int l2;

#ifdef DEBUG
    printf("\tsub_B19()\n");
#endif

    sb = sub_265(sub_306());
    selpsect(P_DATA);
    sub_CAB(sb);		/* Emit "symbolic_name:" (identifier label) */
    l1 = sub_808(sb, sub_4192());
    l2 = (sb->b_refl) ? 2 : sb->b_type->b_size; 
    if(sb->b_nelem == 0) {
      sb->b_nelem = l1/l2;
      sb->b_size  = sub_1C8E(sb);
    }
    sub_76F(']');
#ifdef DEBUG
    printf("\tsub_B19 Return\n");
#endif
}	

/*********************************************************
 * sub_B96 OK++				Used in: sub_2BD0
 * emit_call_ncsv
 *********************************************************/
void sub_B96(int size_stack_frame) {

#ifdef DEBUG
    printf("\tsub_B96(%x)\n", size_stack_frame);
#endif

    selpsect(P_TEXT);
    if(byte_AE0C == 0) {	/* if first call	*/
      printf("global\tncsv, cret, indir\n");
    }
    printf("call\tncsv\n");
    byte_AE0C = 1;		/* first call is done	*/
    printf("defw\tf%d\n", size_stack_frame);
}

/*********************************************************
 * sub_BCC OK++				 Used in: sub_406
 *********************************************************/
void sub_BCC(int p1, int p2) {

#ifdef DEBUG
    printf("\tsub_BCC(%d, %d)\n", p1, p2);
#endif

    selpsect(P_TEXT);
    printf("jp\tcret\n"
	   "f%d\tequ\t%d\n", p1, p2);
}

/*********************************************************
 * sub_BEE OK++				 Used in: sub_406
 *********************************************************/
void sub_BEE(int p1, int p2) {

#ifdef DEBUG
    printf("\tsub_BEE(%d, %d)\n", p1, p2);
#endif

    selpsect(P_TEXT);
    printf("ld\tde,k%d\n"
	   "ld\tbc,%d\n"
	   "ldir\n"
	   "ld\thl,k%d\n", p1, p2, p1);
    selpsect(P_BSS);
    printf("k%d:defs\t%d\n", p1, p2);
}

/*********************************************************
 * sub_C36 OK++       Used in: sub_C57, sub_CAB, sub_4192
 *********************************************************/
void sub_C36(register struct bbb * sb) {

#ifdef DEBUG
    printf("\tsub_C36(%x)\n", sb);
#endif

    printf("global\t%s\n", sb->b_name);
    sb->b_c3 |= 2;
}

/*********************************************************
 * sub_C57 OK++				Used in: sub_5CF5
 *********************************************************/
void sub_C57(register struct bbb * sb) {

#ifdef DEBUG
    printf("\tsub_C57(%x)\n", sb);
#endif

    if((sb->b_c3 & 1) == 0) {
      if(sb->b_nelem != 0) {
	if((LO_CHAR(sb->b_refl) & 2) == 0) {
	  selpsect(P_BSS);
	  if(sb->b_c13 == 3) {
	    if((sb->b_c3 & 2) == 0) {
	      sub_C36(sb);	/* Emit "global name" */
	    }
	  }
	  sub_CAB(sb);	/* Emit "symbolic_name:" (identifier label) */
	  printf("\tdefs\t%u\n", sb->b_size);
        }
      }
    }
}

/*********************************************************
 * sub_CAB OK++			Used in: sub_B19, sub_C57
 *
 * Emit "symbolic_name:" (identifier label)
 *********************************************************/
void sub_CAB(register struct bbb * sb) {

#ifdef DEBUG
    printf("\tsub_CAB(%x)\n", sb);
#endif

    if((sb->b_c3 & 2)  == 0) {
      if(sb->b_c13 == 3) {
	sub_C36(sb);		/* Emit "global name" */
      }	
    }
    sb->b_c3 |= 1;
    printf("%s:\n", sb->b_name);

}

/*********************************************************
 * sub_CDF OK++				 Used in: sub_808
 * Emit "defb 0, ..." (num bytes)
 *********************************************************/
void sub_CDF(int num) {
    char cnt;

#ifdef DEBUG
    printf("\tsub_CDF(%d)\n", num);
#endif

    cnt = 0;				/* Reset counter bytes printed	   */
    while (num-- != 0) {		/* While data is available	   */
      if(cnt == 0) printf("defb\t0");	/* Initially output "defb 0",	   */
      else	   printf(",0");	/* later ",0"			   */ 
      cnt++;				/* and update number bytes output  */
      if(cnt == 0x10) {			/* If number bytes in string is 16 */
	cnt = 0;			/* Reset counter and		   */
	putchar('\n');			/* continue output in next line	   */
      }
    }					/* continue processing		   */
    if(cnt != 0) putchar('\n');		/* If line is incomplete, new line */
}

/*********************************************************
 * selpsect OK++     Used in: sub_6D1,  sub_793,  sub_B19,
 * 			      sub_B96,  sub_BCC,  sub_BEE,
 * Select psect		      sub_C57,  sub_E43  
 *********************************************************/
void selpsect(int section) {

    static char *off_A592[] = {"", "bss", "text", "data"};

#ifdef DEBUG
    printf("\tselpsect(%d)\n", section);
#endif

    if(section != cursect)  /* Only when changing section */
      printf("psect\t%s\n", off_A592[cursect = section]);
}

/*********************************************************
 * sub_D66 OK+				 Used in: sub_E43
 *
 * Generated code from the C source is completely identical,
 * except for useless code in binary image located after
 * L2++ operator, which does not affect function.
 *********************************************************/
void sub_D66(int * v1, int * v2, int p3) {
    char           mark;
    int          * l2;
    int            l3;
    int            l4, l5;
    register int * s1;

#ifdef DEBUG
    printf("\tsub_D66(%d, %d, %d)\n", v1, v2, p3);
#endif

    do {
      mark = 0;						/* m1: */
      s1   = v1;
      l2   = v2;
      l3   = p3;
      while(0 < --l3) {					/* m4: */
	if((int)*(s1+1) >= (int)*(s1+0)) goto m5;	/* m2: */
	mark    = 1;
	l4      = *(s1+0);
	*(s1+0) = *(s1+1);
	*(s1+1) = l4;
	l5      = *l2;
	*(l2+0) = *(l2+1);
	*(l2+1) = l5;
m3:	s1 = s1 + 1;					/* m3: */
	l2++;		/* <--- CGEN binary image at this point contains useless */
      }			/*      code (see disassembled code in B19.as file)      */
    } while(mark != 0);
    return;

m5: if(*(s1+0) != *(s1+1)) goto m3;			/* m5: */
    uerror("Duplicate case label");
    return;
}

/*********************************************************
 * sub_E43 v2 OK++			 Used in: sub_6D1
 *********************************************************/
void sub_E43(void) {
    struct aaa * l1a;
    int  l2, l3, l5, l4, l6, l7, l8;
    char l9, l10;
    int  v1[255], v2[255];
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_E43()\n");
#endif

    l1a = sub_4192();
    l5 = 0;
    for(;;) {
      sa = sub_600E(sub_4192());			/* m1:  */
      l2 = atoi(sub_306());
      if(sa->a_c0 == DOT_DOT) {
	l6 = l2;
	sub_36E0(sa);
	sub_76F(']');
	if(l5 != 0) break;
	warning("No case\tlabels");
	sub_475C(l1a);
	printf("jp\tl%d\n", l6);
	return;
      }
      if(sa->a_c0 == CONST) {				/* m3:  */
	v1[l5]   = sa->a_l15.ii[0];
	v2[l5++] = l2;
      } else {
        uerror("Non-constant case label");		/* m4:  */
      }
      sub_475C(sa);					/* m5:  */
    }
    sub_D66(v1, v2, l5);				/* m6:  */
    l3 = v1[l5-1] - v1[0];
    if(l3 >= 0) {
      if(l3 < 0x3E80) {
	if((l4*2 + 0x14) < l5*5) {
	  sa        = sub_3712();
	  sa->a_c0  = TYPEOP;
	  sa->a_i14 = l1a->a_i14;
	  sa->a_i12 = l1a->a_i12;
	  sa = sub_43EF(CONV, sub_415E(v1[0]), sa);
	  sa = sub_43EF(SUB, l1a, sa);
	  if(nodesize(sa) != 2) {
	    l1a        = sub_3712();
	    l1a->a_c0  = TYPEOP;
	    l1a->a_i14 = sub_265("us");
	    sa         = sub_43EF(CONV, sa, l1a);
	  }
	  selpsect(P_TEXT);				/* m7:  */
	  sub_3DC9(sub_43EF(RPAREN, sa, 0));
	  l3 = sub_174C(); 	/* word_AE0F++ */
	  printf("ld\ta,%u\n"
		 "cp\th\n" 
		 "jp\tc,l%d\n"
		 "jp\tnz,1f\n" 
		 "ld\ta,%u\n"
		 "cp\tl\n"
		 "jp\tc,l%d\n"
		 "1:add\thl,hl\n"
		 "ld\tde,S%u\n"
		 "add\thl,de\n"
		 "ld\ta,(hl)\n"
		 "inc\thl\n"
		 "ld\th,(hl)\n"
		 "ld\tl,a\n" /* hi         lo	*/
		 "jp\t(hl)\n", l4>>8, l6, l4&~(0xFF00), l6, l3); 
	  selpsect(P_DATA);
	  printf("S%d:\n", l3);
	  l2 = 0;
	  l4 = v1[0];
	  do {
	    if(l4 == v1[l2]) {				/* m8:  */
	      printf("defw\tl%d\n", v2[l2]);
	      l2++;
	    } else {
	      printf("defw\tl%d\n", l6);		/* m9:  */
	    }
	    l4++;					/* m10: */
	  } while(l2 < l5);
	  return;
	}
      }
    }  
    if(nodesize(l1a) == 2) {				/* m11: */
      selpsect(P_TEXT);
      sub_3DC9(sub_43EF(RPAREN, l1a, 0));
      l7 = -1;
      l2 = l8 = l10 = l9 = 0;
      while (l2 < l5) {					/* m20: */
        l7 &= v1[l2];					/* m12: */
        l8 |= v1[l2];
        if(l7>>8 != l8>>8) {
	  if((l7&~(0xFF00)) != (l8&~(0xFF00))) {
	    if((l9 | l10 ) != 0) printf("1:\n");
	    l10 = l9 = 0;				/* m13: */
	    l7  = l8 = v1[l2];
	  }
        }
        if(l7>>8 == l8>>8) {				/* m14: */
	  if(l9 == 0) {
	    printf("ld\ta,h\n");
	    sub_1420(l7>>8);
	    printf("jp\tnz,1f\n"
		   "ld\ta,l\n");
	    l9 = 1;
	  }
	  v1[l2] &= ~(0xFF00);				/* m15: */
        } else {
	  if((char)l10 == 0) {				/* m16: */
	    if(l9 != 0) printf("1:\n");
	    printf("ld\ta,l\n");			/* m17: */
	    sub_1420(l7&~(0xFF00));
	    printf("jp\tnz,1f\n" 
	           "ld\ta,h\n");
	    l10 = 1;
          }
          v1[l2] >>= 8;		/* asar */ 		/* m18: */
          v1[l2] &= ~(0xFF00);
        }
        sub_1420(v1[l2]);				/* m19: */
        printf("jp\tz,l%d\n", v2[l2]);
        l2++;
      }
      if((l9 | l10) != 0) printf("1:\n");
      printf("jp\tl%d\n", l6);				/* m21: */
      return;
    }
    selpsect(P_TEXT);					/* m22: */
    sub_3DC9(sub_43EF(INAREG, l1a, 0));
    l2 = 0;
    while (l2 < l5) {
      if((int)v1[l2] < 0x100) {
	if((int)v1[l2] >= 0xFF80) {
	  sub_1420(v1[l2]);
	  printf("jp\tz,l%d\n", v2[l2]);
	}
      }
      l2++;
    }
    printf("jp\tl%d\n", l6);
}

/*********************************************************
 * sub_1420 OK++			 Used in: sub_E43
 *********************************************************/
void sub_1420(int par) {

#ifdef DEBUG
    printf("\tsub_1420(%d)\n", par);
#endif
	
    printf((unsigned)par ? "cp\t%d\n" : "or\ta\n", par);
}

/*********************************************************
 * sub_143F OK++			Used in: sub_35E6
 *********************************************************/
void sub_143F(uchar reg) {

#ifdef DEBUG
    printf("\tsub_143F(%d)\n", reg);
#endif

    if(reg == 0xF) {
      printf("push\thl\n"
	     "push\tde\n");
      return;
    }
    if(7 >= reg) reg = reg/2 + 0xB;
    printf("push\t%s\n", off_AACA[reg]);
}

/*********************************************************
 * sub_1489 OK++			Used in: sub_35E6
 *********************************************************/
void sub_1489(uchar reg) {

#ifdef DEBUG
    printf("\tsub_1489(%d)\n", reg);
#endif

    if(reg == 0xF) {
      printf("pop\tde\n"
	     "pop\thl\n");
      return;
    }
    if(7 >= reg) reg = reg/2 + 0xB;
    printf("pop\t%s\n", off_AACA[reg]);
}

/*********************************************************
 * sub_14D3 OK++			Used in: sub_1EDF
 *
 * Assigning register "IY" value formal parameter with
 * type register
 *********************************************************/
void sub_14D3(register struct bbb * sb) {

#ifdef DEBUG
    printf("\tsub_14D3(%x)\n", sb);
#endif

    printf("ld\tl,(ix+%d)\n"
	   "ld\th,(ix+%d)\n"
	   "push\thl\n"
	   "pop\tiy\n", sb->b_i11, sb->b_i11+1);
}

/*********************************************************
 * sub_14F3 OK++   Used in: sub_153A, sub_2D09, sub_39CA,
 *			    sub_3A79, sub_3EAA, sub_47B2,
 *			    sub_4FCE, sub_508A, sub_54B6,
 *			    sub_60A8, sub_6246, sub_628F
 *********************************************************/
char sub_14F3(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_14F3(%x)\n", sa);
#endif

    if(bittst(sa->a_i12,1) != 0) return 0;
    if(sa->a_i12 != 0) return REG_L;
    if(1 < (unsigned)sa->a_i14->b_nelem) return 0;
    return sa->a_i14->b_c13;
}

/*********************************************************
 * sub_153A OK++			Used in: sub_2D09
 *********************************************************/
void sub_153A(register struct aaa * sa) {

    static char array_A542[] = {0, 'a', 'l', 'f'};

#ifdef DEBUG
    printf("\tsub_153A(%x)\n", sa);
#endif

    putchar(array_A542[(uchar)sub_14F3(sa)]);
}

/*********************************************************
 * sub_155D OK++			 Used in: sub_793
 *
 * Emit "defb byte1, ..." (from ptr num bytes)
 *********************************************************/
void sub_155D(register char * ptr, int num) {
    char cnt;

#ifdef DEBUG
    printf("\tsub_155D(%x, %d)\n", ptr, num);
#endif

    cnt = 0;				/* Reset counter bytes printed	   */
    while (num-- != 0) {		/* While data is available	   */
      if(cnt == 0) printf("defb\t");	/* Initially output "defb",	   */
      else	   putchar(',');	/* later "," 			   */   
      printf("%d", (uchar)*(ptr++));	/* Output byte and advance pointer */
      cnt++;				/* update number bytes output 	   */
      if(cnt != 0x10) continue; 	/* If number bytes in string is 16 */
      putchar('\n');			/* continue output in next line    */
      cnt = 0;				/* Reset counter and		   */
    }					/* continue processing		   */
    if(cnt != 0) putchar('\n');		/* If line is incomplete, new line */
}

/*********************************************************
 * xx1	 OK++		Used in: Explicit calls are absent
 *********************************************************/
void sub_15D3(int p) {

#ifdef DEBUG
    printf("\tsub_15D3(%d)\n", p);
#endif

    printf("j%d:\n", p);
}

/*********************************************************
 * xx2	 OK++		Used in: Explicit calls are absent
 *********************************************************/
void sub_15E7(int p) {

#ifdef DEBUG
    printf("\tsub_15E7(%d)\n", p);
#endif

    printf("jp\tj%d\n", p);
}

/*********************************************************
 * sub_15FB OK++			Used in: sub_1B0C
 *********************************************************/
void sub_15FB(register struct bbb * sb, int p2, int p3) {

#ifdef DEBUG
    printf("\tsub_15FB(%x, %d, %d)\n", sb, p2, p3);
#endif

    if((HI_CHAR(p2) & 0x80) != 0) goto m3;
    sb->b_c13 = 2;
    if(0xFF < p3) goto m2;
    LO_CHAR(sb->b_size) = 1;
m1: HI_CHAR(sb->b_size) = 0;
    return;

m2: LO_CHAR(sb->b_size) = 2;
    goto m1;

m3: sb->b_c13 = 1;
    if(0x7F < p3)   goto m2;
    if(p2 < 0xFF80) goto m2;
    LO_CHAR(sb->b_size) = 1;
    goto m1;
}

/* End of file - sub_B19.c  */


/*
 * File - sub_1659.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_1659 OK++			Used in: sub_1CEF
 * Find maximum between two numbers
 *********************************************************/
int sub_1659(int num1, int num2) {

#ifdef DEBUG
    printf("\tsub_1659(%x, %x)\n", num1, num2);
#endif

    return (num1 > num2 ) ? num1 : num2;
}

/* End of file - sub_1659.c  */


/*
 * File - sub_1680.c Created 09.03.2019 Last Modified 21.01.2021
 */

#include "stdio.h"
#include <string.h>
#include "cgen.h"

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

/*********************************************************
 * sub_1680 OK++			    Used in: main
 *
 * first_init
 *********************************************************/
void sub_1680(void) {
    struct bbb           * sb;
    unsigned               cnt;
    register struct type * tp;

/*
 *	Initializaion of type pointers
 */
    static struct type vars[14] = {  /* sub_1680 */
      {"i",  2, 0, 1}, {"s",  2, 0, 1}, {"c",  1, 0, 1},
      {"l",  4, 0, 1}, {"ui", 2, 0, 2}, {"us", 2, 0, 2},
      {"uc", 1, 0, 2}, {"ul", 4, 0, 2}, {"f",  4, 0, 3},
      {"d",  4, 0, 3}, {"x",  2, 0, 1}, {"ux", 2, 0, 2},
      {"b",  0, 0, 0}, {"v",  0, 0, 0}
    };

#ifdef DEBUG
    printf("\tsub_1680()\n");
#endif

    /* Clear hash table */

    blkclr((char *)hashtab, sizeof(hashtab));

    /* Create a hash table of templates for standard types */

    cnt = ARRAY_SIZE(vars);
    tp = vars;
    do {
      sb = sub_265(tp->t_str);
      sb->b_class  = TDECL;
      sb->b_i11    = tp->t_alig;
      sb->b_size   = tp->t_size;
      sb->b_c13    = tp->t_flag;
      tp++;
      cnt--;
    } while (cnt != 0);

    /* Additional patterns for types */

    word_AE11 = sub_265("l");	/* long	  	*/
    word_AED7 = sub_265("d");	/* double 	*/
    word_AF1B = sub_265("b");	/* b   	  	*/
    word_AFE9 = sub_265("v");	/* variable 	*/
    word_AED9 = sub_265("c");	/* char   	*/
    word_AE53 = sub_265("uc");	/* uchar  	*/
    word_AF1D = sub_265("x");	/* x      	*/
    lvlidx = -1;
}

/*********************************************************
 * sub_174C OK++    Used in: sub_E43,  sub_17E0, sub_39CA,
 *			     sub_4192, sub_508A
 *********************************************************/
int sub_174C(void) {

#ifdef DEBUG
    printf("\tsub_174C()\n");
#endif

    return ++word_AE0F;
}

/*********************************************************
 * sub_1754 OK++    Used in: sub_17E0, sub_19C1, sub_1B0C
 *********************************************************/
struct bbb * sub_1754(char * token, int p2) {
    struct          bbb **l1b;
    register struct bbb * sb;

#ifdef DEBUG
    printf("\tsub_1754(%s, %d)\n", token, p2);
#endif
	
    sb = sub_265(token);			/* Set pointer to struct associated with   */
						/* pointer to token.			   */
    if((uchar)sb->b_ndpth != nstdpth) {		/* If nesting depth not correspond current,*/
      l1b        = gethashptr(token);		/* Get pointer to pointer to struct from   */
      sb         = allocmem(sizeof(struct bbb));/* hash table. Create new struct and save  */
      sb->b_next = *l1b;			/* pointer to struct from hash table in    */
      						/* struct as associated with it. 	   */
      *l1b       = sb;				/* Save pointer to this struct in current  */
						/* position hash table.			   */
      sb->b_name = allocmem(strlen(token)+1);	/* Get memory address allocated for token  */ 
						/* and assign it to corresponding member.  */
      strcpy(sb->b_name, token);		/* Copy specified token to this address.   */
      sb->b_ndpth = nstdpth;			/* Save current nesting depth in struct    */
/*
      if(++symcnt > dynmem)   dynmem = symcnt;
*/
    }
    sb->b_class = p2;
#ifdef DEBUG
    printf("\tsub_1754\t\tReturn %x\n", sb);
#endif
    return sb;
}

/* End of file sub_1680.c  */


/*
 * File - sub_17E0.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_17E0 OK+			Used in: sub_6D1, sub_4192
 *
 * Compiler generates identical code from restored source
 * program in C, however, location of branches associated
 * with case constants is different from original.
 * This does not affect the function.
 *********************************************************/
void sub_17E0(void) {
    struct aaa          * l1a;
    int                   l2;
    register struct bbb * sb;

#ifdef DEBUG
    printf("\tsub_17E0()\n");
#endif

    sb         = sub_1754(sub_306(), DECL9);
    sb->b_type = sub_627(sub_306(), &sb->b_refl);
    l1a        = sub_600E(sub_4192());
    if(l1a->a_c0 != CONST)
      faterror("Bad element count expr");
    sb->b_nelem = l1a->a_l15.ii[0]; /* ??? */
    sub_475C(l1a);
    l2 = *sub_306();
    sub_76F(']');

#ifdef DEBUG
    printf("\tsub_17E0\t\tl2=%c\n", l2);
#endif

    switch (l2) {
      case 'A':		/* auto		*/
      case 'a':	  
        sb->b_c13 = 1;
        break;
      case 'E':		/* extern	*/
      case 'e':
        sb->b_c13 = 3;
        break;
      case 'R':		/* register	*/
      case 'r':
        sb->b_c3 |= 8;
      case 'P':		/* pointer	*/
      case 'p':
        sb->b_c13 = 5;
        break;
      case 'S':		/* static 	*/
      case 's':
        sb->b_c13 = 4;
        break;
      case 'T':		/* typedef	*/
      case 't':
        sb->b_class = TDECL;
        if(sb->b_refl != 0) {
          sb->b_i11 = 0;
          sb->b_c13 = 2;
        } else {
          sb->b_i11 = sb->b_type->b_i11;
          sb->b_c13 = sb->b_type->b_c13;
        }
        if(sb->b_nelem != 1) {
          sb->b_c13 = 0;
        }
        break;
      default:
        faterror("Bad storage class");
    }
    sb->b_size = sub_1C8E(sb);
    if(sb->b_class != TDECL) {
      if((sb->b_refl         == 0) &&
         (sb->b_size         == 0) &&
         (sb->b_type->b_size == 0)) {
	uerror("Bad dimensions");
      }
      switch (sb->b_c13) {
	case 1:
	case 5:
	  sub_5CF5(sb, l2);
	  break;
	default:
	  sb->b_i11 = sub_174C(); /* word_AE0F++ */
      }
      if((sb->b_refl & 0x2) != 0) {
	if(sb->b_nelem != 0) {
	  if(++lvlidx == MAXFUN) {
	    faterror("Functions nested too deep");
	  }
	  array_AE57[lvlidx] = nstdpth; /* Save current nesting depth */
	  array_AE97[lvlidx] = 6;
	  array_AE13[lvlidx] = 0;
	  array_AEDB[lvlidx] = sb;
	}
      }
    }
#ifdef DEBUG
    printf("\tsub_17E0\t\t Exit\n");
#endif
}

/* End of file sub_17E0.c  */


/*
 * File - sub_19C1.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include <stdlib.h>
#include "cgen.h"

/*********************************************************
 * sub_19C1 OK++	       Used in: sub_6D1, sub_4192
 *********************************************************/
void sub_19C1(int p1) { 
    int			  l1;
    struct bbb		* l2b;
    int			* l3;
    struct aaa		* l4a;
    char		* l5;
    int			  arr[258];
    register struct bbb * sb;

#ifdef DEBUG
    printf("\tsub_19C1(%d)\n", p1);
#endif

    l2b = sub_1754(sub_306(), p1);
    l3  = arr;
    *l3 = 0;
    for(;;) {
      l5 = sub_306();
      if(*l5 == ']') break;
      sb = (struct bbb *)allocmem(sizeof(struct bbb)); /* Create struct bbb */
      sb->b_class = MEMBER;
      if(*l5 == ':') {
        LO_CHAR(sb->b_i5) = atoi(l5+1);
	bitset(sb->b_c3, 4);
	l5 = sub_306();
      }
      sb->b_type = sub_627(l5, &sb->b_refl);
      l4a	 = sub_600E(sub_4192());
      if(l4a->a_c0 != CONST) faterror("Strucdecl - bad\tnelem");
      sb->b_nelem  = l4a->a_l15.ii[0];
      sub_475C(l4a);
      sb->b_size  = sub_1C8E(sb);
      *(((++(*l3))-1) + l3 +1) = sb;	/* assigning to "int" from "struct bbb *" */
/*
      ++membcnt;
*/
    }
    l1 = (0xffff + (unsigned)*l3)*2 + 4;
    l3 = allocmem(l1);			/* create ??? */
    movmem(arr, l3, l1);
    l2b->b_memb = l3;
    sub_1CEF(l2b);
}

/*********************************************************
 * sub_1B0C OK++		Used in: sub_6D1, sub_4192
 *
 * In original executable file CGEN stack recovery code is
 * missing when returning from sub_76F function
 *********************************************************/
void sub_1B0C(void) {
    struct aaa		* l1a;
    int			* l2;
    int			  l3;
    int			  l4;			
    int			* l5;
    int			  arr[258];
    register struct bbb * sb;

#ifdef DEBUG
    printf("\tsub_1B0C()\n");
#endif

    l3  = MININT;		/* arithmetic overflow in constant expression */
    l4  = MAXINT;
    sb  = sub_1754(sub_306(), EDECL);
    l2  = arr;
    *l2 = 0;
    for(;;) {
      l1a = sub_4192();
      if(l1a->a_c0 == DOT_DOT) {
	sub_475C(l1a);
	l5 = ((*l2) - 1)*2 + 4;	/* assigning to "int *" from "int" */
	l2 = allocmem(l5);	/* passing "int *" to parameter type "int" */	/* create ??? */
	movmem(arr, l2, l5);
	sb->b_memb = l2;	/*	 In file CGEN.COM stack	recovery */
	sub_15FB(sb, l4, l3);	/*	 failed when returning from	 */
	sub_76F(']');		/* <---- function sub_76F 		 */
	return;
      }
      l1a = sub_600E(l1a);

      *(((++(*l2))-1) + l2 +1) = l1a->a_l15.ii[0];
	  
      if(    (long)l3 < l1a->a_l15.l) l3 = l1a->a_l15.ii[0];
      if(l1a->a_l15.l < (long)l4)     l4 = l1a->a_l15.ii[0];
      sub_475C(l1a);
    }
}

/* End of file sub_19C1.c  */


/*
 * File - sub_1C6D.c Created 19.03.2019 Last Modified 04.04.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_1C6D OK++			Used in: sub_1CEF
 *********************************************************/
int sub_1C6D(int p1, int p2) {

#ifdef DEBUG
    printf("\tsub_1C6D(%x, %x)\n", p1, p2);
#endif

    return (p1 + p2) & ((-1) - p2);
}

/* End of file sub_1C6D.c  */


/*
 * File - sub_1C8E.c  Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_1C8E OK++   Used in: sub_B19, sub_17E0, sub_19C1
 *********************************************************/
int sub_1C8E(register struct bbb * sb) {

#ifdef DEBUG
    printf("\tsub_1C8E(%x)\n", sb);
#endif

    if((sb->b_refl & 0x1) != 0) return sb->b_nelem*2;
    return sb->b_type->b_size*(sb->b_nelem);
}

/*********************************************************
 * sub_1CC4 OK++	       Used in: sub_808, sub_1CEF
 *********************************************************/
int sub_1CC4(register struct bbb * sb) {

#ifdef DEBUG
    printf("\tsub_1CC4(%x)\n", sb);
#endif

    if(sb->b_refl != 0) return 0;
    return sb->b_type->b_i11;
}

/*********************************************************
 * sub_1CEF OK++			Used in: sub_19C1
 *********************************************************/
void sub_1CEF(register struct bbb * sb) {
    int		 l1;
    int		 l2;
    int		 l3;
    struct bbb * l4b;

#ifdef DEBUG
    printf("\tsub_1CEF(%x)\n", sb);
#endif

    l1 = 0;
    l2 = l3 = 0;
    while (l2 != *sb->b_memb) { 			/* m9: */
      l4b = *(sb->b_memb + l2 + 1);			/* m1: */ /* assigning to "struct bbb *" from "int"*/
      if(sb->b_class == UDECL) {
	l1 = sub_1659(l1, l4b->b_size);	/* return max number */
	l4b->b_i11 = 0;
	goto m8;
      }
      l1 = l4b->b_i11 = sub_1C6D(l1, sub_1CC4(l4b));	/* m2: */
      if((l4b->b_c3 & 0x10) != 0) {
	if((0x10 < (l3 + (uchar)LO_CHAR(l4b->b_i5)))
	|| (LO_CHAR(l4b->b_i5) == 0)) {
	  if(l3 != 0) {					/* m3: */
	    l4b->b_i11 = (l1 += 2);
	  }
	  l3 = 0;					/* m4: */
	}
        HI_CHAR(l4b->b_i5) = LO_CHAR(l3);		/* m5: */
        l3 += (uchar)LO_CHAR(l4b->b_i5);
        if(l3 != ' ') goto m8;
        l3 = 0;
        l1 += 2;
        goto m8;
      }
      if(l3 != 0) {					/* m6: */
	l3 = 0;
	l4b->b_i11 = (l1 += 2);
      }
      l1 += l4b->b_size;				/* m7: */
m8:   l2++;
    }
    if(l3 != 0) {
      l3 = 0;
      l1 += 2;
    }
    sb->b_size  = sub_1C6D(l1, 0);			/* m10: */
    sb->b_i11   = 0;
    sb->b_class = SDECL;
}

/*********************************************************
 * sub_1EDF OK++			Used in: sub_2BD0
 *********************************************************/
void sub_1EDF(void) {
  struct bbb   	     ** l1b;
  register struct bbb * sb;

#ifdef DEBUG
  printf("\tsub_1EDF()\n");
#endif
	
  l1b = hashtab;
  do {
    sb = *l1b;
    while ((sb != 0) && ((uchar)sb->b_ndpth == nstdpth)) {
      if(sb->b_class == DECL9) {
	if(sb->b_c13 == 2) {
	  if((sb->b_c3 & 4) != 0) sub_14D3(sb); /* Assigning register "IY" value formal parameter with type register */
	}
      }
     sb = sb->b_next;
    }
  } while (++l1b != &word_AFE9);	/* variable */
}

/* End of file sub_1C6D.c  */


/*
 * File - sub_1F4B.c Created 09.03.2019 Last Modified 21.01.2021
 */

#include "stdio.h"
#include <ctype.h>
#include "cgen.h"

/* int asdf; */
/*********************************************************
 * sub_1F4B OK+ (optim: Out of memory)	Used in: sub_2BD0
 *********************************************************/
int sub_1F4B(struct aaa * p1a, int p2, int p3, int p4, int * p5) {
    int l1, l2, l3, l4, l5, l6, l7, l8;
    register struct zzz * sz;

#ifdef DEBUG
    printf("\tsub_1F4B(%x, %d, %d, %d, %x)\n", p1a, p2, p3, p4, p5);
#endif

/**/
    if(p1a->a_c1 == 0) p1a->a_c2 = 0;
    if((l1 = sub_13D(p2, p1a->a_c0)) == 0) return (-1);
#if 1
    if(dummy1(p1a, p3, p4) == -1) return (-1);
#else
/* 
    if(p4 != 0) {
      if((p4 & 0x8000) == 0) {
        if(sub_6589(p3, p4) == (int)0) {
          if(p1a->a_c0 != USEREG) return (-1);
          if(sub_6589(array_AAE8[p1a->a_l15.ii[0]], p4) == (int)0) return (-1);
        }
      }
    }
*/
#endif

m4: if(l1 > 0) word_AFED = l5 = array_A162[l1++];
    else       word_AFED = l5 = l1;
k6: if(word_AFED < 0) word_AFED = (0 - word_AFED);	/* ok */
k7: sz = &array_80EF[word_AFED];

    if((sz->c_2 != 0) && (sub_6589(p3, sz->c_2) == 0)) goto m9;

k8: if((uchar)sz->c_3 < 'H') {
      if(sz->c_4 != 0) {
        if(sub_13D((uchar)sz->c_4, p1a->a_l15.wi[0]->a_c0) == 0) goto m9;
        if(sz->c_5 != 0) {
          if(sub_13D((uchar)sz->c_5, p1a->a_l15.wi[1]->a_c0) == 0) {
m9:         if(l5 >= 0) goto m4;			/* ok */
            return (-1);
          }
        }
      }
    }
/**/

/*
m9: if(((unsigned)l5 & 0x8000) != 0) return (-1);
    asdf = 1;
*/ 

/**/
k10:if((sz->c_0 != 0) && (sub_47B2(p1a, sz->c_0) == 0)) goto m9;
k11:l6 = sz->c_1;
    l7 = 0;
    if((p4 == 0) && (sz->c_3 == 'E')) p4 = sz->c_3;
k12:if(p4 != 0) {
      if((p4 & 0x8000) != 0) {
        if(l6 != 0) {
          if(sub_6589(p4 & (~0x8000), l6) == 0) goto m30; 	
        }
      }
k13:  if((word_AFEF = sz->p_8) != 0) {
        if((*word_AFEF == 'L') && (*(word_AFEF+1) == 0)) word_AFEF = "GL"; /* array_A94A */
k28:    while (*(word_AFEF) != 0) {
k14:      byte_AFF3 = *word_AFEF;
          if(byte_AFF3 == 'X') goto m15;
          if(byte_AFF3 == 'G') goto m15;
          if(byte_AFF3 != 'S') goto m26;
          if(p1a->a_c0 == USEREG) goto m15;
          goto m26;
m15:      if(isdigit(*(++word_AFEF)) != 0) word_AFF1 = word_AFEF;
          else			           word_AFF1 = (char *)0;
          while (*(word_AFEF) < 'A') word_AFEF++;
          if(*(word_AFEF) == 'L') goto m20;
          if(*(word_AFEF) == 'N') goto m23;
          if(*(word_AFEF) != 'R') continue;
          goto m22;

m20:      if((l6 = sub_66BC(l6, p4, p3, word_AFF1)) == 0) {
m21:        l6 = -1;
          }
          goto m30;

m22:      l7 = p4;
          goto m30;

m23:      if(byte_AFF3 != 'S') goto m25;
          if(p1a->a_c0 != USEREG) goto m30;
          if(sub_66BC(l6, p4, array_AAE8[p1a->a_l15.ii[0]], word_AFF1) == 0) {
            l6 = -1;
          }
          goto m30;

m25:      if(sub_63B8(p3, p4, sz->c_2) != 0) goto m30;
          if((p4 & 0x8000) == 0) goto m21;
          if(sub_66BC(sz->c_2, p4, p3, word_AFF1) == 0) {
            l6 = -1;
          }
          goto m30;
m26:	  word_AFEF++;
        }
      } else {
k29:    if((l6 = sub_66BC(l6, p4, p3, 0)) == 0) l6 = -1;
      }
    }
/**/
m30:if(l6 == -1) goto m9;
    l4 = 0;
    if((uchar)sz->c_3 >= 'H') {
      p1a->a_c1 = 0;
      if(sub_1F4B(p1a, (uchar)sz->c_3, p3, l6, &l2) >= 0) goto m42; /* ok */
      p1a->a_c1 = 0;
      goto m9;
    }
k31:if(sz->c_4 != 0) {
      *(p1a->a_l15.ci[0]+1) = 0;
      if(sub_1F4B(p1a->a_l15.wi[0], (uchar)sz->c_4, p3, l6, &l2) < 0) goto m9; /* ok */
      if(sz->c_5 == 0) goto m42;
      *(p1a->a_l15.ci[1]+1) = 0;
      l8 = sub_2B2A(p1a->a_l15.wi[0]);
      if(l7 == 0) {
        if(sz->c_2 != 0) l7 = array_AAE8[(uchar)sub_63B8(p3, p4, sz->c_2)];
        else		 l7 = 0;
k33:    l7 = ((l8 | l7) != 0) ? (((unsigned)(l8 | l7)) | 0x8000) : 0;
      }
k36:  if(sub_1F4B(p1a->a_l15.wi[1], (uchar)sz->c_5, p3, l6, &l3) < 0) goto m9; /* ok */
      l4 = sub_2B2A(p1a->a_l15.wi[1]);
      if((l4 | l8) != 0) {
        *(p1a->a_l15.ci[1]+1) = 0;
        if(0 >= sub_1F4B(p1a->a_l15.wi[1], (uchar)sz->c_5, (p3 & ((-1)-l8)), l7, &l3)) goto m9;
        l4 = sub_2B2A(p1a->a_l15.wi[1]);
      }
k37:  if((dopetab[p1a->a_c0] & 0x100) != 0) goto m38;		/* LOGOP & QUEST */
      if((l4 & l2) != 0) {
m38:    if((l8 & l3) != 0) { 		/* m38: */
          if((dopetab[p1a->a_c0] & 0x100) != 0) goto m9;	/* LOGOP & QUEST */
          p1a->a_c2 = 2;
          l4 = 0;
          goto m42;
        } else {
k39:      p1a->a_c2 = 1; 		/* m39: */
          goto m42;
        }
      }
k40:  p1a->a_c2 = 0;			/* m40: */
    } else {
k41:  if(l6 != 0) p4 = l6;
    }
m42:if(sz->c_2 != 0) { 
      word_AFF4 = p3;
      if((sz->c_2 & 0x40) == 0) goto m43;
      word_AFF6 = (unsigned)sub_63B8(sub_2B2A(p1a), p4, sz->c_2);
      if(word_AFF6 == 0) {
m43:    if((sz->c_2 & 0x40) == 0) word_AFF4 &= ((-1) - sub_2B2A(p1a));
k44:    word_AFF4 &= ((-1) - l4);
        word_AFF6 = (unsigned)sub_63B8(word_AFF4, p4, sz->c_2);
        if(word_AFF6 == 0) {
          word_AFF6 = (uchar)sub_6589(word_AFF4, sz->c_2);
          if(word_AFF6 == 0) goto m9;
        }
      }
k45:  *((uchar)p1a->a_c1 + (uchar*)p1a + 9) = word_AFF6;
    } else {
k46:  *((uchar)p1a->a_c1 + (uchar*)p1a + 9) = 0;
    }
k47:*((uchar)(p1a->a_c1++) + (uchar*)p1a + 3) = (sz - array_80EF);
    word_AFF6 = (uchar)sub_2B79(p1a);
    *((uchar*)p1a + (uchar)p1a->a_c1 + 0xE) = word_AFF6;
    if(word_AFF6 == 0)   {
      if(p1a->a_c0 == USEREG) {
        *((uchar*)p1a + (uchar)p1a->a_c1 + 0xE) = (word_AFF6 = p1a->a_l15.ii[0]);
      }
    }
k48:if(p4 != 0) {
      if((p4 & 0x8000) == 0) {
        if(word_AFF6 == 0) goto m58;
        if((uchar)sub_6589(((p4 & 0x8000) != 0) ? 
        ((-1) - p4) : 
        array_AAE8[p4], word_AFF6) != word_AFF6) goto m58;
      }
    }

#if 1
    if(dummy2(p4)  == -1) {
      p1a->a_c1--;
      goto m9;
    }
#else
k51:if((p4 & 0x8000) != 0) {	
      if((((p4 & 0x8000) ? (-1) - p4 : array_AAE8[p4]) & 
      ((word_AFF6 & 0x8000) ? (-1) - word_AFF6 : array_AAE8[word_AFF6])) != 
      ((word_AFF6 & 0x8000) ? (-1) - word_AFF6 : array_AAE8[word_AFF6])) {
m58:    p1a->a_c1--;
        goto m9;
      }
    }
#endif

k59:*p5 = array_AAE8[*((uchar*)p1a + (uchar)p1a->a_c1 + 8)];
    if(((uchar)sz->c_3 >= 'H') || (sz->c_4 != 0)) *p5 |= l2;
    if(sz->c_5 != 0) *p5 |= l3;
    return 1;
}

/* End of file sub_1F4B.c  */

#if 1
/*
 * dummy1
 */
int dummy1(struct aaa * p1a, int p3, int p4) {

#ifdef DEBUG
    printf("\tdummy1(%x, %d, %d)\n", p1a, p3, p4);
/*
    pr_st_a(p1a);
*/
#endif

    if(p4 != 0) {
      if((p4 & 0x8000) == 0) {
        if(sub_6589(p3, p4) == (int)0) {
          if(p1a->a_c0 != USEREG) return (-1);
          if(sub_6589(array_AAE8[p1a->a_l15.ii[0]], p4) == (int)0) return (-1);
        }
      }
    }
    return 0;
}

/*
 * dummy2
 */
int dummy2(int p4) {
#ifdef DEBUG
    printf("\tdummy2(%d)\n", p4);
#endif

    if(p4 != 0) {
      if((p4 & 0x8000) == 0) {
        if(word_AFF6 == 0) goto m58;
        if((uchar)sub_6589(((p4 & 0x8000) != 0) ? ((-1) - p4) : array_AAE8[p4], word_AFF6) != word_AFF6) goto m58;
      }
    }
    if((p4 & 0x8000) != 0) {	
      if((((p4 & 0x8000) ? (-1) - p4 : array_AAE8[p4]) & 
      ((word_AFF6 & 0x8000) ? (-1) - word_AFF6 : array_AAE8[word_AFF6])) != 
      ((word_AFF6 & 0x8000) ? (-1) - word_AFF6 : array_AAE8[word_AFF6])) {
m58:    return -1;
      }
    }
    return 0;
}
#endif

/*
 * File - sub_283E.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include <ctype.h>
#include "cgen.h"

/*********************************************************
 * sub_283E OK+				 Used in: sub_2B2A
 *
 * Restored source code did not allow optimizer to reduce
 * number of sub_2B2A function calls to one.
 *
 * The switch statement, in comparison with if, more clearly
 * reflects the structure of the program, however, fragments
 * of the generated assembler code are arranged in an order
 * different from the original.
 *********************************************************/
 int sub_283E(register struct aaa * sa, int par) {
    char	* l1;
    struct zzz 	* l2z;
    struct aaa 	* l3a;
    char	* l4;
    char	  l5;
    int		  l6;
    int		  l7;

#ifdef DEBUG
    printf("\tsub_283E(%x, %x)\n", sa, par);
#endif

    l2z = &array_80EF[*(par + (uchar*)&sa->a_c3)];
    l7  = 0;
    l1  = l2z->p_8;
m1: if(*(l1) == 0) return l7 & word_B017;
    switch (l5 = *(l1++)) {
      case 'A':
      case 'B':
      case 'C':
      case 'F':
      case 'M':
      case 'O':
      case 'P':
      case 'Q':
      case 'S':
      case 'T':
      case 'V':
      case 'W':
      case 'Z':
        for(;;l1++) {						/* m23: */
          if(*l1 == 0)   goto m1;				/* m24: */
          if(*l1 == 'N') goto m1;
          if(*l1 == 'L') goto m1;
          if(*l1 == 'R') goto m1;						
        }
      case 'D':
      case 'U':
        goto  m1;
      case 'X':
      case 'G':
        if(isdigit(*l1) != 0) {					/* m4:	*/
          l4 = l1;
          while(isdigit(*l1) != 0) {l1++;};
        } else {
          l4 = 0;						/* m7:  */
        }
        switch (*(l1++)) {					/* m8:	*/
          case 'L':
            if(0 < par) {					/* m11: */
              l3a = sa;
              l6  = par-1;
              break;
            }
            l6 = *((uchar*)(l3a = sa->a_l15.wi[0])+1)-1;	/* m14: */
            break;
          case 'N':
            l6  = par;						/* m10: */
            l3a = sa;
            break;
          case '~':
            l6 = *((uchar*)(l3a = sa->a_l15.wi[1])+1)-1;	/* m15: */
            break;
        }
        if(l5 == 'S') {						/* m9: */
          if(l3a->a_c0 == USEREG) {
            l5 = l3a->a_l15.bc[0];
          } else {
            l5 = 0;						/* m16: */
          }
        } else {
          l5 = (l5 == 'G') ?					/* m17: */
          *(l6 + (uchar *)&l3a->a_i9) :
          *(l6 + (uchar *)&l3a->a_i6);
          if(l4 != 0) {
            while (isdigit(*((char *)par)) != 0) {	/* cast to "char *" from smaller integer type "int" */
              l5 = array_AB24[(uchar)l5*2 +((-48) + *(l4++))];
            }
          }
        }
        l7 |= array_AAE8[(uchar)l5];				/* m22: */
        if(l5 != 0) byte_AFFA = l5;
        goto m1;
      case 'L':
        l7 |= (0 >= par) ?					/* m27: */
        sub_2B2A(sa->a_l15.wi[0]) :
        sub_283E(sa, par-1);
        goto m1;
      case 'R':
        l7 |= sub_2B2A(sa->a_l15.wi[1]);			/* m31: */
        goto m1;
      case '~':
        for(;;l1++) {						/* m25: */
          if(*l1 == 0)   goto m1;				/* m26: */
          if(*l1 == 'L') goto m1;
          if(*l1 == 'R') goto m1;
        }
    }
    goto m1;
}

/* End of file sub_283E.c  */


/*
 *  File - sub_2B2A.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_2B2A OK+      Used in: sub_1F4B, sub_283E, sub_2B79
 *********************************************************/
int sub_2B2A(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_2B2A(%x)\n", sa);
#endif

    if((sa->a_c1) == 0) {
      if((dopetab[sa->a_c0] & 0xC) == 0) return 0;
      return sub_2B2A(sa->a_l15.wi[0]);			/* LOGOP & QUEST */
    }
    return sub_283E(sa, sa->a_c1 - 1); /* Generated code has insignificant differences */
}

/* End of file sub_2B2A.c  */


/*
 * File - sub_2B79.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_2B79 OK++			 Used in: sub_1F4B
 *********************************************************/
uchar sub_2B79(register struct aaa * sa) {
    uchar l1;
    int   l2;

#ifdef DEBUG
    printf("\tsub_2B79(%x)\n", sa);
#endif

    l1 = *((char*)sa + sa->a_c1 + 8);
    byte_AFFA = 0;
    l2 = sub_2B2A(sa);
    if(l1 != 0) {	
      if(sub_6589(l2, l1) == l1) return l1;
    }
    return byte_AFFA;
}

/*********************************************************
 * sub_2BD0 OK++      Used in: sub_793, sub_808, sub_3CDF
 *			       sub_3DC9
 *********************************************************/
void sub_2BD0(register struct aaa * sa) {
    int tmp;

#ifdef DEBUG
    printf("\tsub_2BD0(%x)\n", sa);
#endif

    sa->a_c1 = 0;

    if(sub_1F4B(sa, 0x48, word_B017, 0, &tmp) <= 0) {
      faterror("Expression too complicated");
    }
    sub_35E6(sa);
    if(sa->a_c0 == COLON_U) {
      if((sa->a_i12 & 2) != 0) {
        sub_B96(array_AEDB[lvlidx]->b_i11); /* emit_call_ncsv */
        sub_1EDF();
      }
      if(  sa->a_l15.wi[0]->a_c0 == IDOP) {
        sa->a_l15.wi[0]->a_l15.wi[0]->a_c3 |= 1;
      }
    }
    sub_475C(sa);
}

/* End of file sub_2B79.c  */


/*
 * File - sub_2C5E.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_2C5E OK+	   	      Used in: sub_2CE0, sub_47B2
 *
 * Compiler generates code that performs expected action,
 * but differs from original image
 *********************************************************/
long sub_2C5E(struct aaa * sa, long p2) {
    char loc;

#ifdef DEBUG
    printf("\tsub_2C5E(%x, %lx)\n", sa, p2); 
#endif

    if((loc = nodesize(sa) << 3) >= 0x20) return p2; 	
    if((p2 & ((long)1 << (loc - 1))) != 0) {	
      p2 |= (-1) - (((long)1<<loc) - 1);  /* No code matching */
    }
    return p2;
}

/* End of file sub_2C5E.c */


/*
 * File - sub_2CE0.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 *  sub_2CE0 OK++			Used in: sub_2D09
 *********************************************************/
void sub_2CE0(struct aaa * p1a, long p2) {

#ifdef DEBUG
    printf("\tsub_2CE0(%x, %lx)\n", p1a, p2); 
#endif

    printf("%ld", sub_2C5E(p1a, p2));
}

/* End of file sub_2CE0.c */


/*
 * File - sub_2D09.c	BIG size - problems compiling v3.09
 */

#include "stdio.h"
#include "ctype.h"
#include "cgen.h"

int     atoi(char *);

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*.......................................................*
 *  sub_2D09_v2 optim: Out of memory	Used in: sub_3564
 *.......................................................*/
void sub_2D09(register struct aaa * sa, char * p2, int p3) {

  struct zzz	* lz1;	/*   ix+0FFh (ix+-1)  h  \	*/
			/*   ix+0FEh (ix+-2)  l _/li1 	*/	
  struct aaa	* la2;	/*   ix+0FDh (ix+-3)  h  \	*/
			/*   ix+0FCh (ix+-4)  l _/li2 	*/	
  char 		* li3;	/* + ix+0FBh (ix+-5)  h  \	*/
			/* + ix+0FAh (ix+-6)  l _/li3 	*/	
  uchar 	  lc4;	/* + ix+0F9h (ix+-7)  h __lc4 	*/
  char 		  lc5;	/* + ix+0F8h (ix+-8)  l __lc5 	*/
  char 		  lc6;	/*   ix+0F7h (ix+-9)  __lc6	*/
  char 		  lc7;	/*   ix+0F6h (ix+-10) __lc7 	*/
  int  		  li8;	/*   ix+0F5h (ix+-11) h  \	*/
			/*   ix+0F4h (ix+-12) l _/li8 	*/	
  unsigned long   ll9;	/* + ix+0F3h (ix+-13) h  \	*/
			/* + ix+0F2h (ix+-14) l  |ll9 	*/	
			/* + ix+0F1h (ix+-15) h  | 	*/	
			/* + ix+0F0h (ix+-16) l _/ 	*/	
  char 		  lc10;	/*   ix+0EFh (ix+-17)  __lc10 	*/
  char 		  lc11;	/*   ix+0EEh (ix+-18)  __lc11 	*/
  char 		* li12;	/*   ix+0EDh (ix+-19) h  \	*/
			/*   ix+0ECh (ix+-20) l _/li12	*/	
  unsigned long   ll13;	/* + ix+0EBh (ix+-21) h  \ \ 	*/
			/* + ix+0EAh (ix+-22) l  |_/	*/	
		 	/* + ix+0E9h (ix+-23) h  | \ 	*/
			/* + ix+0E8h (ix+-24) l _/_/ll13*/	
  char 		  lc15;	/* ; ix+0E7h (ix+-25)  __lc15 	*/

#ifdef DEBUG
    printf("\tsub_2D09(%x, %x, %d)\n", sa, p2, p3);
#endif

    li12 = p2;
    lc11 = lc15 = 0;		
m1: lc7  = *(p2++);
    if(lc7 == 0) return;

    switch(lc7) {
      case '\n':
      case '\r':
        putchar('\n');					/* m4	*/
        lc15 = 0;
        goto m1;

      case ' ':
        if(lc15 == 0) {					/* l3:	*/
          putchar('\t');
          lc15 = 1;
        } else {
	  putchar(lc7);
        }
	goto m1;

      case ';':
        return;

      case 'A':
      case 'B':
      case 'C':
      case 'F':
      case 'M':
      case 'O':
      case 'P':
      case 'Q':
      case 'S':
      case 'T':
      case 'V':
      case 'W':
      case 'Z':
      case '~':
	if( ((li8 = *p2) == '-') || (li8 == '+')) {
	  if(isdigit(*(++p2)) != 0) {
	    lc5 = atoi(p2);
	    if(li8 == '-') lc5 = -lc5;
	    li8 = 0;
	  } else {
	    lc5 = 0;
	  }
	  while((isdigit(*p2) != 0) || (*p2 == '+') || (*p2 == '-'))  p2++;
	} else {
	  if(li8 == '>') {
	    for(lc5 = 0; *p2 == '>'; p2++, lc5++) ;
	  } else {
	    li8 = 0;
	    lc5 = 0;
	  }
	}
	lc6 = *(p2++);
        break; /* goto m10; */

      case 'G':
      case 'X':
        if(isdigit(*p2) != 0) {				/* m5:	*/						
          li3 = p2;
          while(isdigit(*p2) != 0) p2++;
        } else {
          li3 = 0;					/* m8:	*/
        }
        lc6 = *(p2++);					/* m9:	*/
        li8 = 'G';
        break; /* goto m10; */

      case 'L':
      case 'R':
      case 'U':
        lc6 = lc7;					/* m24: */
        lc7 = '~';
        li8 = 0;					/* m25: */
        lc5 = 0;
        break; /* goto m10; */

      case 'D':
        lc6 = lc7;					/* m26: */
        li8 = 0;
        lc5 = 0;
        break; /* goto m10; */

      default:
        putchar(lc7);					/* m2:	*/
        goto m1;					/* m3:	*/
    }
/*
m10:
*/
    switch(lc6) {
      case 'L':
/*
m27:	if(0 < (char)p3) {
	  la2  = sa;
	  lc10 = (char)p3 + (-1);
	} else {
m29:	  la2  = sa->a_l15.wi[0];
m30:	  lc10 = la2->a_c1 + (-1);
	}
m28:	lz1  = &array_80EF[*(lc10 + (uchar*)&la2->a_c3)];
        break;
*/
        if(0 < (char)p3) {				/* m27: */
          la2  = sa;
          lc10 = (char)p3 + (-1);
m28:      lz1  = &array_80EF[*(lc10 + (uchar*)&la2->a_c3)];
	  break; /* goto m11; */
	}
	la2  = sa->a_l15.wi[0];				/* m29: */
m30:	lc10 = la2->a_c1 + (-1);
	goto m28;

      case 'N':
        la2  = sa;					/* m32: */
        lc10 = (char)p3;
        break; /* goto m11; */

      case 'R':
    	la2 = sa->a_l15.wi[1];				/* m31: */
        goto m30;
    }
/*
m11:
*/
    switch(lc7) {
      case 'A':
        sub_153A(la2);					/* m51: */
        goto m1;

      case 'B':
        ll9 = sub_387A(la2); 				/* m45: */
m46:    if(li8 == '-') {
          if(lc11 == 0) {
            ll13 = ll9 + (long)word_AFF8;
            word_AFF8 = 0;
            lc11 = 1;
            goto m54;
          }
        }	
        printf("%lu", ll9);				/* m47: */
        goto m1;

      case 'C':
        if(la2->a_c0 == BFIELD) {			/* m63:	*/
          printf("%d", la2->a_l15.wi[1]->a_c6);
        } else {
          ll9 = la2->a_l15.l;				/* m64: */
          if(sub_46F7(ll9) == 0) ll9 = (-1) - ll9;
/*        word_AFF8 += ((sub_46F7(ll9) - 1)>>3); */	/* m65: */
          word_AFF8 += ((-1) + sub_46F7(ll9))/8;
        }
        goto m1;

      case 'D':
        if(word_AFF8 != 0) {				/* m33: */
          printf("%d", word_AFF8);
          word_AFF8 = 0;
        }
        goto m1;

      case 'F':						/* m43: */
        printf("%d", la2->a_l15.ii[1]);
        goto m39;

      case 'G':
      case 'X':
        lc4 = (lc7 == 'G') ?				/* m69: */
        *(lc10 + (uchar*)&la2->a_i9) : 
        *(lc10 + (uchar*)&la2->a_i6);
        if(li3 != 0) {
          while(isdigit(*li3) != 0) {			/* m73: */
            lc4 = (char)array_AB24[lc4*2 +((-48) + *(li3++))]; 	/* m72: */
          }
        }
        if(*p2 != '+') {				/* m74: */   
          lc4 += word_AFF8;
          word_AFF8 = 0;
        }
        printf("%s", off_AACA[lc4]);			/* m75: */
        goto m1;

      case 'O':
        printf("%s", array_805F[la2->a_c0]);		/* m49: */
        goto m1;

      case 'S':
/**/
	if     (la2->a_c0 == USEREG) printf("%s", off_AACA[la2->a_l15.ii[0]]);
	else if(la2->a_c0 ==  CONST) sub_2CE0(la2, la2->a_l15.l);
	else if(la2->a_c0 == FCONST) printf("%s", la2->a_l15.ci[0]);
	else			     printf("%s", la2->a_l15.vi[0]->b_name);
/**/
/*
        switch(la2->a_c0) {				
          case 'E':
            printf("%s", off_AACA[la2->a_l15.ii[0]]);
            break;
          case 'C':					
            sub_2CE0(la2, la2->a_l15.l);
            break;
          case 'D':					
            printf("%s", la2->a_l15.ci[0]);
            break;
          default:					
            printf("%s", la2->a_l15.vi[0]->b_name);
        }
*/
m39:    if(li8 == 0) {
          lc5 += word_AFF8;
          word_AFF8 = 0;
          if(word_AFF8 < lc5) printf("+%d", lc5);
          else if(lc5 < 0)    printf("%d",  lc5);
        }
        goto m1;

      case 'T':
        if(la2->a_c0 == BFIELD) {			/* m66: */
          printf("%d", la2->a_l15.wi[1]->a_c5);
        } else {
          ll9 = la2->a_l15.l;				/* m67: */
          if(sub_46F7(ll9) == 0) ll9 = -1 - ll9;
          printf("%d", (-1) + sub_46F7(ll9));
        }
        goto m1;

      case 'V':
        if((li8 == '-') || (li8 == '+')) {		/* m52: */
          if(lc11 == 0) {				/* m53: */
            ll13 = la2->a_l15.l + word_AFF8;
            word_AFF8 = 0;
            lc11 = 1;
          }
m54:	  ll13 += (li8 == '-') ? (long)(-1) : (long)1;
          if(sub_14F3(la2) == REG_L) {
            if(nodesize(la2) < 4) {
              ll13 &= ((int)(1<<(nodesize(la2)*8)) - 1);
            }
          }
          if(ll13 != 0) {				/* m57: */
            for(;(li12 < p2 && *(p2-1) != '\n');p2--) ;	/* m59: */ 
            putchar('\n');				/* m60: */
          } else {
            lc11 = 0;					/* m61: */
          }
        } else {
          lc5 += word_AFF8;				/* m62: */
          word_AFF8 = 0;
          sub_2CE0(la2, (la2->a_l15.l >> (lc5<<3)));
        }
        goto m1;

      case 'Z':
        ll9 = nodesize(la2);				/* m44: */
        goto m46;

      case '~':
        if(lc6 == 'U') {				/* m76: */
          lc5 += word_AFFB;
          if(((unsigned)dopetab[sa->a_c0] & 0x200) != 0) {
            if((char)p3 != 0) lc5--;
          }
          printf("%d", lc5);				/* m77: */
        } else {
          word_AFF8 += lc5;				/* m78: */
          sub_2D09(la2, lz1->p_8, lc10);
        }
        /* goto m1; */
    }
    goto m1;
}

/* End of file sub_2D09.c */



/*
 * File - sub_3564.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_3564 OK++			Used in: sub_35E6
 *********************************************************/
void sub_3564(register struct aaa * sa) {
    char         l1;
    struct zzz * l2z;

#ifdef DEBUG
    printf("\tsub_3564(%x)\n", sa);
#endif

    word_AFF8 = 0;
    l1 = 0;
    while ((unsigned)l1 != sa->a_c1) {
      if(((l2z = &array_80EF[*(&sa->a_c3 + l1)]))->p_6 != 0) {
        sub_2D09(sa, l2z->p_6, l1);
        putchar('\n');
      }
      l1++;
    }
#ifdef DEBUG
    printf("\tsub_3564\t\tReturn\n");
#endif
}

/*********************************************************
 * sub_35E6 OK+				Used in: sub_2BD0
 *
 * Minor differences in the generated code
 *********************************************************/
void sub_35E6(register struct aaa * sa) {
    int l1;

#ifdef DEBUG
    printf("\tsub_35E6(%x)\n", sa);
#endif

    if((dopetab[sa->a_c0] & 0x200) != 0) word_AFFB++;
    l1 = dopetab[sa->a_c0] & 0xC;
    if(8 == l1) { 
      if((bittst(sa->a_c2, 0)) != 0) {
        sub_35E6(sa->a_l15.wi[0]);
        sub_35E6(sa->a_l15.wi[1]);
      } else {
        sub_35E6(sa->a_l15.wi[1]);
        if((bittst(sa->a_c2, 1)) != 0) {
          /* Following statement creates code that is not
             significantly different from  original. */
          sub_143F(*(sa->a_l15.wi[1]->a_c1 + &sa->a_l15.wi[1]->a_c0 + 0xE));
        }
        sub_35E6(sa->a_l15.wi[1]);
      }
    }
    if(l1 == 4) {
      sub_35E6(sa->a_l15.wi[0]);
    }
    if((bittst(sa->a_c2, 1)) != 0) {
      /* Following statement creates code that is not
         significantly different from  original. */
      sub_1489(*(sa->a_l15.wi[1]->a_c1 + &sa->a_l15.wi[1]->a_c0 + 0xE));
    }
    sub_3564(sa);
    if((dopetab[sa->a_c0] & 0x200) != 0) word_AFFB--;
}

/*********************************************************
 * sub_36E0 OK++   Used in: sub_E43,  sub_39CA, sub_3CDF, 
 *			    sub_3DC9, sub_3EAA, sub_43EF,
 *			    sub_475C, sub_4C8B, sub_4FA8,
 *			    sub_508A, sub_53EE, sub_54B6,
 *			    sub_5DF6, sub_5F52
 *********************************************************/
void sub_36E0(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_36E0(%x)\n", sa);
#endif
 
    (byte_B013) = 1;
    if(sa->a_c0 == FCONST) {
      sub_7028((struct ptr *)sa->a_l15.wi[0]);
    }
    sa->a_i14 = word_B011;
    word_B011 = sa;
/*  
    --nodecnt;
*/
}

/*********************************************************
 * sub_3712 OK++    Used in: sub_E43,  sub_377A, sub_415E,
 *			     sub_4192, sub_43EF, sub_4DA3,
 *			     sub_54B6
 *********************************************************/
struct aaa * sub_3712(void) {
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_3712()\n");
#endif

    byte_B013 = 1;
    if(word_B011 != 0) {
      sa = word_B011;
      word_B011 = sa->a_i14;
      blkclr((char *)sa, sizeof(struct aaa));
    } else { /* create struct aaa */
      sa = (struct aaa *)allocmem(sizeof(struct aaa));
    }
/*
    if(++nodecnt > nodes) nodes = nodecnt;
*/
#ifdef DEBUG
    printf("\tsub_3712\t\tReturn %x\n", sa);
#endif
    return sa;
}

/*********************************************************
 *  sub_374C OK++			Used in: allocmem
 *********************************************************/
char sub_374C(void) {
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_374C()\n");
#endif

    if(word_B011 == 0) return 0;
    while((sa = word_B011) != 0) {
      word_B011 = sa->a_i14;
      sub_7028((struct ptr *)sa);
    }	
    return 1;
}

/*********************************************************
 *  sub_377A OK++			Used in: sub_3CDF
 *********************************************************/
struct aaa * sub_377A(struct aaa * p1a) {
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_377A(%x)\n", p1a);
#endif

    sa = sub_3712();
    *(sa) = *(p1a); 

    if((dopetab[sa->a_c0] & 0xC) != 0) {
      sa->a_l15.wi[0] = sub_377A(sa->a_l15.wi[0]);
    }
    if((dopetab[sa->a_c0] & 0xC) == 8) {
      sa->a_l15.wi[1] = sub_377A(sa->a_l15.wi[1]);
    }
    return sa;
}

/* End of file sub_3564.c  */


/*
 * File - sub_37ED.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_37ED v1 OK+	      Used in: sub_387A, sub_43EF
 *
 * Elegantly designed function leads to the generation of
 * less optimal code, unlike the second version
 *********************************************************
void sub_37ED(register struct aaa * sa) {
    struct bbb * l1b;

#ifdef DEBUG
    printf("\tsub_37ED(%x)\n", sa);
#endif

    l1b = sa->a_i14;
    if(sa->a_i12 != 0) {
      sa->a_i12 >>= 2;
    } else {
      while(l1b->b_refl == 0) l1b = l1b->b_type;
      sa->a_i14 = l1b->b_type;
      sa->a_i12 = (l1b->b_refl)>>2;
    }
}
*/

/*********************************************************
 * sub_37ED v2 OK++	      Used in: sub_387A, sub_43EF
 *
 * This version generates code identical to binary image
 *********************************************************/
void sub_37ED(register struct aaa * sa) {
    struct bbb * l1b;

#ifdef DEBUG
    printf("\tsub_37ED(%x)\n", sa);
#endif

    l1b = sa->a_i14;
    if(sa->a_i12 == 0) goto m2;
    sa->a_i12 >>= 2;
    return;

m1: l1b = l1b->b_type;
m2: if(l1b->b_refl == 0) goto m1;
    sa->a_i14 = l1b->b_type;
    sa->a_i12 = (l1b->b_refl)>>2;
}

/* End of file sub_37EDD.c  */


/*
 * File - sub_385B.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include <string.h>
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_385B OK++    Used in: sub_387A, sub_43EF, sub_4DA3,
 *			     sub_4E8D
 *********************************************************/
void sub_385B(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_385B(%x)\n", sa);
#endif

    sa->a_i12 = (sa->a_i12*4)|1;
}

/*********************************************************
 * sub_387A OK++			Used in: sub_2D09
 *********************************************************/
int sub_387A(register struct aaa * sa) {
    char loc;

#ifdef DEBUG
    printf("\tsub_387A(%x)\n", sa);
#endif
	
    if(sa->a_i12 != 0) goto m1;
    if(sa->a_i14->b_type != 0) goto m1;
    if(sa->a_i14->b_refl != 0)  goto m1;
    return 1;
m1: sub_37ED(sa);
    loc = nodesize(sa);
    sub_385B(sa);
    return (uchar)loc;
}

/*********************************************************
 * sub_38CA OK++	      Used in: sub_393C, sub_3952
 *********************************************************/
int sub_38CA(struct aaa * p1a, int p2) {
    register struct bbb * sb;

#ifdef DEBUG
    printf("\tsub_38CA(%x, %d)\n", p1a, p2);
#endif

    if((p1a->a_i12 & p2) != 0) return 1;
    if(p1a->a_i12 != 0) return 0;
    sb = p1a->a_i14;
    do {
      if((sb->b_refl & p2) != 0) return 1;
      if(sb->b_refl != 0) return 0;
    } while ((sb = sb->b_type) != 0);
  return 0;
}


/*********************************************************
 * sub_393C OK++			Used in: Not used
 *********************************************************/
int sub_393C(struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_393C(%x)\n", sa);
#endif

    return sub_38CA(sa, 1);
}


/*********************************************************
 * sub_3952 OK++			Used in: Not used
 *********************************************************/
int sub_3952(struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_3952(%x)\n", sa);
#endif

    return sub_38CA(sa, 2);
}


/*********************************************************
 * sub_3968 OK++			Used in: sub_47B2
 *********************************************************/
int sub_3968(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_3968(%x)\n", sa);
#endif

    if(sa->a_i14->b_class == SDECL) {
      if(((sa->a_i12) & 1) == 0) return 1;
    }
    return 0;
}

/*********************************************************
 * nodesize OK++    Used in: sub_808,  sub_E43,  sub_2C5E,
 *			     sub_2D09, sub_387A, sub_3A79,
 *			     sub_43EF, sub_47B2, sub_508A,
 *			     sub_54B6, sub_60A8, sub_6246,
 *			     sub_62BE
 *********************************************************/
unsigned nodesize(register struct aaa * sa) {

#ifdef DEBUG
    unsigned tmp;
    printf("\tnodesize(%x)\t", sa);
#endif

    if((sa->a_i12 & 2) != 0) {
      uerror("can\'t take sizeof func");
    }
#ifdef DEBUG
    if((sa->a_i12 & 1) != 0) tmp = 2;
    else                     tmp = sa->a_i14->b_size;
    printf("\tReturn %d\n", tmp);
    return tmp;
#else
    if((sa->a_i12 & 1) != 0) return 2;
    return sa->a_i14->b_size;
#endif
}

/*********************************************************
 * sub_39CA OK++			Used in: sub_3EAA
 *********************************************************/
struct aaa * sub_39CA(register struct aaa * sa) {
    char buf[34];

#ifdef DEBUG
    printf("\tsub_39CA(%x)\n", sa);
#endif

    sub_36E0(sa->a_l15.wi[1]);
    if(sub_14F3(sa) == REG_F) {
      sprintf(buf, "%ld.", sa->a_l15.wi[0]->a_l15.l);
      sub_36E0(sa->a_l15.wi[0]);
      sa->a_l15.ci[0] = allocmem(strlen(buf)+1); /* create string */
      strcpy(sa->a_l15.ci[0], buf);
      sa->a_l15.ii[1] = sub_174C(); /* word_AE0F++ */
      sa->a_c0        = FCONST;
      return sa;
    }
    sub_3A79(sa, sa->a_l15.wi[0]);
    sub_36E0(sa);
    return sa->a_l15.wi[0];
}

/* End of file sub_385B.c  */


/*
 * File - sub_3A79.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_3A79 OK+	              Used in: sub_3EAA, sub_39CA
 *
 * Compiler generates code that performs expected action,
 * but differs from original image
 *********************************************************/
void sub_3A79(register struct aaa * sa, struct aaa * p2a) {
    int l1;

#ifdef DEBUG
    printf("\tsub_3A79(%x, %x)\n", sa, p2a);
#endif

    l1 = nodesize(sa);
    if(l1 != 0) {
      if(l1 < 4) {
        l1 <<= 3;
        p2a->a_l15.l &= ((long)1<<l1) + (-1);
        if(sub_14F3(sa) == REG_A) {
          if((p2a->a_l15.l & (1<<(l1-1))) != 0) {
            p2a->a_l15.l |= ((-1) - (((long)1<<l1) - 1)); /* no code matching */
          }
        }
      }
    }
    p2a->a_i14 = sa->a_i14;
    p2a->a_i12 = sa->a_i12; 
}

/* End of file sub_3A79.c  */


/*
 * File - sub_3B65.c Created 09.03.2019 Last Modified 29.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_3B65 OK++			Used in: sub_3EAA
 *********************************************************/
void sub_3B65(register unsigned long * ptr, long p2, int operator) {

#ifdef DEBUG
    printf("\tsub_3B65(%x, %lx, %d)\n", ptr, p2, operator);
#endif

    switch (operator) {
      case MOD:	   *ptr /=  p2;  break;
      case DIV:    *ptr %=  p2;  break;
      case RSHIFT: *ptr >>= p2;  break;
    }
    return;
}

/* End of file sub_3B65.c  */


/*
 * File - sub_3BC6.c Created 09.03.2019 Last Modified 29.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_3BC6 v1 OK+			Used in: sub_3EAA
 *
 * Compiler generates identical code from restored source
 * program in C, however, location of branches associated
 * with case constants is different from original.
 * This does not affect the function.
 *********************************************************/
void sub_3BC6(register long * ptr, long p2, int operator) {

#ifdef DEBUG
    printf("\tsub_3BC6(%x, %lx, %d)\n", ptr, p2, operator);
#endif

    switch(operator) {
      case MOD:    *ptr %=  p2;  break;
      case BAND:   *ptr &=  p2;  break;
      case MUL:    *ptr *=  p2;  break;
      case ADD:    *ptr +=  p2;  break;
      case SUB:    *ptr -=  p2;  break;
      case DIV:    *ptr /=  p2;  break;
      case LSHIFT: *ptr <<= p2;  break;
      case RSHIFT: *ptr >>= p2;  break;
      case BXOR:   *ptr ^=  p2;  break;
      case BOR:    *ptr |=  p2;  break;
    }
    return;
}

/* End of file sub_3BC6.c  */


/*
 * File - sub_3CDF.c Created 09.03.2019 Last Modified 31.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_3CDF OK++			Used in: sub_3DC9
 *********************************************************/
struct aaa * sub_3CDF(register struct aaa * sa) {
    int loc;

#ifdef DEBUG
    printf("\tsub_3CDF(%x)\n", sa);
#endif

    if(sa->a_c0 == SCOLON) {
      sub_2BD0(sa->a_l15.wi[0]);
      sub_36E0(sa);
      sa = sa->a_l15.wi[1];
    }
    if(byte_B014 != 0xA) {
      if((dopetab[sa->a_c0] & 0x4000) != 0) return sa;
      switch(sa->a_c0) {
        case INCR:
        case DECR:
          if(sub_4C6D(sa) != 0) {
            array_AFFD[byte_B014++] = sa;
            sa->a_c0 = (sa->a_c0 == INCR) ? ASADD : ASSUB;
            sa = sub_377A(sa->a_l15.wi[0]);
          }
      }
      loc = dopetab[sa->a_c0]/*& 0xC */;
      if((loc & 0xC) != 0) sa->a_l15.wi[0] = sub_3CDF(sa->a_l15.wi[0]);
      if((loc & 0xC) == 8) sa->a_l15.wi[1] = sub_3CDF(sa->a_l15.wi[1]);
    }
    return sa;
}

/*********************************************************
 * sub_3DC9 OK++		Used in: sub_6D1, sub_D66
 *********************************************************/
void sub_3DC9(register struct aaa * sa) {
    unsigned loc;

#ifdef DEBUG
    printf("\tsub_3DC9(%x)\n", sa);
#endif

    sa = sub_600E(sa);
    if(sa->a_c0 == DOLLAR) {
      if(sa->a_l15.wi[0]->a_c0 == CONST) {
        warning("constant conditional branch");
        if(sa->a_l15.wi[0]->a_l15.l != 0) {
          sa->a_c0 = DOLLAR_U;
          sub_36E0(sa->a_l15.wi[0]);
          sa->a_l15.wi[0] = sa->a_l15.wi[1];
        } else {
          sub_475C(sa);
          return;
        }
      }
    }
    byte_B014 = 0;
    if(sa->a_c0 == INCR) {
      sa->a_c0 = ASADD;
    } else {
      if(sa->a_c0 == DECR) {
        sa->a_c0 = ASSUB;
      }
    }
    sa = sub_3CDF(sa);
    if(byte_B014 != 0) sa = sub_600E(sa);
    sub_2BD0(sa);
    loc = 0;
    while(loc < byte_B014) {
      sub_2BD0(array_AFFD[loc]);
      loc++;
    }
}

/* End of file sub_3CDF.c */


/*
 * File - sub_3EAA.c Created 09.03.2019 Last Modified 29.05.2020
 */

#include "stdio.h"
#include <stdlib.h>
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_3EAA OK+				Used in: sub_600E
 *********************************************************/
#if 1
/*vvvvvvvvvvvvvvvvvvvvvvvvvvv*/

struct aaa * sub_3EAA(register struct aaa * sa) {
    struct aaa * l1a;
    int		 l2;

#ifdef DEBUG
    struct aaa * tmp;
    printf("\tsub_3EAA(%x)\n", sa);
#endif

    if((l2 = dopetab[sa->a_c0] & 0xC) != 0)
      sa->a_l15.wi[0] = sub_3EAA(sa->a_l15.wi[0]);
    if(l2 == 8) sa->a_l15.wi[1] = sub_3EAA(sa->a_l15.wi[1]);
    if(sa->a_c0 == CONV) {
      if((sa->a_l15.wi[0])->a_c0 == FCONST) {
        if(sub_14F3(sa) == REG_F) {
          l1a = sa->a_l15.wi[0];
          l1a->a_i14 = sa->a_i14;
          sub_36E0(sa->a_l15.wi[1]);
          sub_36E0(sa);
#ifdef DEBUG
          tmp = l1a;
          goto d2;
#else 
          return l1a;
#endif
        }
      }
    }
m3: if((l2 == 0) || ((sa->a_l15.wi[0])->a_c0 != CONST)) {
#ifdef DEBUG
      goto d1;
#else
      return sa;
#endif
    }
m6: if(sa->a_c0 == CONV) {

#ifdef DEBUG
      tmp = sub_39CA(sa);
      goto d2;
#else
      return sub_39CA(sa);
#endif
    }
m7: if((l2 != 8) || ((sa->a_l15.wi[1])->a_c0 != CONST)) goto m8; 

#ifdef DEBUG
d1: tmp = sa;
d2: printf("\tsub_3EAA\t\tReturn %x\n", tmp);
    return tmp;
#else 
    return sa;
#endif
m8:   if(sub_14F3(sa) == REG_L) {		/* m8:  */
        switch(sa->a_c0) {
          case MOD:
          case DIV:
          case RSHIFT: goto m14;
          case LT:
          case LEQ:
          case GT:
          case GEQ:    goto m12;
        }
      }
m10:  switch(sa->a_c0) {			/* m10: */
        case BNOT:    goto m23;
        case NOT:     goto m21;
        case MINUS_U: goto m19;
        case BAND:
        case LAND:
        case SUB:
        case BXOR:
        case BOR:
        case LOR:
        case ADD:
        case MUL:
        case DIV:
        case MOD:
        case RSHIFT:
        case LSHIFT:  goto m18;
        case NEQL:
        case LT:
        case LEQ:
        case EQL:
        case GT:
        case GEQ:     goto m17;
        default:   {  
#ifdef DEBUG
		      goto d1;
#else
        	      return sa;
#endif
        	   }
      }
/*    return sa; */

m12:word_B015 = "constant relational expression";	
#ifdef DEBUG
    goto d1;
#else
    return sa;
#endif

m14:sub_3B65(&sa->a_l15.wi[0]->a_l15.ul, sa->a_l15.wi[1]->a_l15.l, sa->a_c0);
m15:if(l2 == 8) {
      sub_475C(sa->a_l15.wi[1]);
    }
    sub_3A79(sa, sa->a_l15.wi[0]);	/* m16: */
    sub_36E0(sa);
#ifdef DEBUG
    tmp = sa->a_l15.wi[0];
    goto d2;
#else
    return sa->a_l15.wi[0];
#endif

/* Two identical code fragments could be intended for different messages */

m17:word_B015 = "constant relational expression";	
#ifdef DEBUG
    goto d1;
#else
    return sa;
#endif

m18:sub_3BC6(&sa->a_l15.wi[0]->a_l15.l, sa->a_l15.wi[1]->a_l15.l, sa->a_c0);
    goto m15;

m19:sa->a_l15.wi[0]->a_l15.l = (long)0 - sa->a_l15.wi[0]->a_l15.l;
    goto m15;

m21:sa->a_l15.wi[0]->a_l15.l = sa->a_l15.wi[0]->a_l15.l == 0 ?
    (long)1 : (long)0; /* minor differences in the generated code */
    goto m15;

m23:sa->a_l15.wi[0]->a_l15.l =
    (long)(-1) - sa->a_l15.wi[0]->a_l15.l; /* minor differences in the generated code */
    goto m15;
}

/*^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#else
/*vvvvvvvvvvvvvvvvvvvvvvvvvvv*/
struct aaa * sub_3EAA(register struct aaa * sa) {
    struct aaa * l1a;
    int		 l2;

#ifdef DEBUG
    printf("\tsub_3EAA(%x)\n", sa);
#endif

    if((l2 = dopetab[sa->a_c0] & 0xC) != 0)
      sa->a_l15.wi[0] = sub_3EAA(sa->a_l15.wi[0]);
    if(l2 == 8) sa->a_l15.wi[1] = sub_3EAA(sa->a_l15.wi[1]);
    if(sa->a_c0 == CONV) {
      if((sa->a_l15.wi[0])->a_c0 == FCONST) {
        if(sub_14F3(sa) == REG_F) {
          l1a = sa->a_l15.wi[0];
          l1a->a_i14 = sa->a_i14;
          sub_36E0(sa->a_l15.wi[1]);
          sub_36E0(sa);
          return l1a;
        }
      }
    }
m3: if((l2 == 0) || ((sa->a_l15.wi[0])->a_c0 != CONST))  return sa;
m6: if(sa->a_c0 == CONV) return sub_39CA(sa);
m7: if((l2 != 8) || ((sa->a_l15.wi[1])->a_c0 != CONST))  goto m8; 
    return sa;

m8:   if(sub_14F3(sa) == REG_L) {		/* m8:  */
        switch(sa->a_c0) {
          case MOD:
          case DIV:
          case RSHIFT: goto m14;
          case LT:
          case LEQ:
          case GT:
          case GEQ:    goto m12;
        }
      }
m10:  switch(sa->a_c0) {			/* m10: */
        case BNOT:    goto m23;
        case NOT:     goto m21;
        case MINUS_U: goto m19;
        case BAND:
        case LAND:
        case SUB:
        case BXOR:
        case BOR:
        case LOR:
        case ADD:
        case MUL:
        case DIV:
        case MOD:
        case RSHIFT:
        case LSHIFT:  goto m18;
        case NEQL:
        case LT:
        case LEQ:
        case EQL:
        case GT:
        case GEQ:     goto m17;
        default:      return sa; 
      }
/*    return sa; */

m12:word_B015 = "constant relational expression";	
    return sa;

m14:sub_3B65(&sa->a_l15.wi[0]->a_l15.ul, sa->a_l15.wi[1]->a_l15.l, sa->a_c0);
m15:if(l2 == 8) {
      sub_475C(sa->a_l15.wi[1]);
    }
    sub_3A79(sa, sa->a_l15.wi[0]);	/* m16: */
    sub_36E0(sa);
    return sa->a_l15.wi[0];

/* Two identical code fragments could be intended for different messages */

m17:word_B015 = "constant relational expression";	
    return sa;

m18:sub_3BC6(&sa->a_l15.wi[0]->a_l15.l, sa->a_l15.wi[1]->a_l15.l, sa->a_c0);
    goto m15;

m19:sa->a_l15.wi[0]->a_l15.l = (long)0 - sa->a_l15.wi[0]->a_l15.l;
    goto m15;

m21:sa->a_l15.wi[0]->a_l15.l = sa->a_l15.wi[0]->a_l15.l == 0 ?
    (long)1 : (long)0; /* minor differences in the generated code */
    goto m15;

m23:sa->a_l15.wi[0]->a_l15.l =
    (long)(-1) - sa->a_l15.wi[0]->a_l15.l; /* minor differences in the generated code */
    goto m15;
}
/*^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#endif
/* End of file sub_3EAA.c  */


/*
 * File - sub_415E.c  Created 09.03.2019 Last Modified 26.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_415E OK++   Used in: sub_808,  sub_E43,  sub_4192,
 *			    sub_4DA3, sub_54B6
 *********************************************************/
struct aaa * sub_415E(long number) {
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_415E(%ld)\n", number);
#endif
    sa          = sub_3712();
    sa->a_c0    = CONST;
    sa->a_i14   = word_AE11;	/* "l" - long	  */
    sa->a_l15.l = number;
#ifdef DEBUG
    printf("\tsub_415E\t\tReturn %x\n", sa);
#endif
    return sa;
}

/* End of file sub_415E.c  */


/*
 * File - ssub_4192.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include <ctype.h>
#include <string.h>
#include "cgen.h"
#include <stdlib.h> 

/*********************************************************
 * sub_4192 OK+     Used in: sub_6D1,  sub_793,  sub_808,
 *			     sub_B19,  sub_E43,  sub_17E0,
 *			     sub_19C1, sub_1B0C 
 *
 * Generated code is completely identical to binary image
 * executable file, with exception location some branches
 * switch statements
 *********************************************************/
struct aaa * sub_4192(void) {
    struct aaa          * l1a;
    char	        * l2;
    int 	 	  l3;
    int			  l4;
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_4192()\n");
#endif

m1: l2 = sub_306();
    if(isdigit(*l2) != 0) goto m2;
    if((*l2 != '-') || (isdigit(*(l2+1)) == 0)) goto m7;
m2: if(*l2 == '-') {
      l4 = 1;
      l2++;
    } else {
      l4 = 0;						/* m4:  */
    }

#ifdef DEBUG
    printf("\tsub_4192\t\tatol(\"%s\") = %ld l4 = %d\n", l2, atol(l2), l4);
#endif

    sa = sub_415E(atol(l2));
    if(l4 != 0) sa->a_l15.l = 0 - sa->a_l15.l;
m5: 
#ifdef DEBUG
    printf("\tsub_4192\t\tReturn %x\n", sa);
#endif
    return sa;

m7: if((*l2 == '_') || (isalpha(*l2) != 0)) {		/* m7:  */
      (sa = sub_3712())->a_c0 = IDOP;			/* m8:  */
      sa->a_l15.vi[0]         = sub_265(l2);
      sa->a_i14               = sa->a_l15.vi[0]->b_type;
      sa->a_i12               = sa->a_l15.vi[0]->b_refl;
      if(sa->a_l15.vi[0]->b_c13 != 3) goto m5;
      if(((sa->a_l15.vi[0]->b_c3) & 2) != 0) goto m5;
      sub_C36(sa->a_l15.vi[0]);				/* Emit "global name" */
      goto m5;
    }
    if(*l2 == '`') {					/* m9:  */
      sa        = sub_3712();			
      sa->a_i14 = sub_627(l2, &sa->a_i12);
      sa->a_c0  = TYPEOP;
      goto m5;
    }
    if(*l2 == '.') {					/* m10: */
      if(*(l2+1) != 0) {
        if(*(l2+1) != '.') {
          sa              = sub_3712();
          sa->a_i14       = word_AED7;			/* "d" - double */
          sa->a_l15.ci[0] = (char*)allocmem(strlen(l2)); /* create string */
          strcpy(sa->a_l15.ci[0], l2+1);
          sa->a_l15.ii[1] = sub_174C();			/* word_AE0F++ */
          sa->a_c0        = FCONST;
          goto m5;
        }
      }
    }
    l4 = sub_1B2(l2);	/* Token search */		/* m12: */
    l3 = dopetab[l4] & 0xC;
    switch(l3) {
      case 0xC:				/* parsing operations	    */
        switch(l4) {
          case '4':
            sub_1B0C();
            goto m1;
          case '7':
          case '8':
            sub_19C1(l4);
            goto m1;
          case '9':
            sub_17E0();
            goto m1;
        }
        faterror("Expression error");
      case 0:				/*  			    */
        return sub_43EF(l4, 0, 0);
      case 4:				/*  			    */
        return sub_43EF(l4, sub_4192(), 0);
      case 8:				/* computational operations */
        l1a = sub_4192();
        return sub_43EF(l4, l1a, sub_4192());
    }
    goto m1;
}

/* End of file sub_4192.c  */


/*
 * File - sub_43EF.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_43EF OK+      Used in: sub_793,  sub_808,  sub_E43,
 *                            sub_4192, sub_4C8B, sub_4DA3,
 *                            sub_4E8D, sub_508A, sub_54B6,
 *                            sub_5DF6
 *
 * Generated code is completely identical, except for
 * location of code of branches of "switch" operator.
 *********************************************************/
struct aaa * sub_43EF(int p1, struct aaa * p2a, struct aaa * p3a) {
    struct bbb 		* l1b;
    long		  l2;
    register struct aaa * sa;

#ifdef DEBUG
    printf("\tsub_43EF(%d, %x, %x)\n", p1, p2a, p3a);
#endif

    sa              = sub_3712();
    sa->a_c0        = (char)p1;
    sa->a_l15.wi[0] = p2a;
    sa->a_l15.wi[1] = p3a;
    switch(dopetab[sa->a_c0] & 0x30) {
      case 0x10:
        sa->a_i14 = word_AE11;			/* long	  */
        break;

      case 0x20:
        sa->a_i14 = word_AF1B;			/* b	  */
        break;

      case 0x30:
        sa->a_i14 = word_AFE9;			/* variable */
        break;

      default:
        sa->a_i14 = p2a->a_i14;
        sa->a_i12 = p2a->a_i12;
    }
    switch(sa->a_c0) {
      case HASHSIGN:
        if(sa->a_l15.wi[0]->a_c0 == IDOP)
          l2 = (unsigned)sa->a_l15.wi[0]->a_l15.wi[0]->a_i6;
        else
          l2 = (unsigned)nodesize(sa->a_l15.wi[0]); /* ?? */
        if(l2 == 0) warning("Sizeof yields 0");
        sub_475C(sa->a_l15.wi[0]);
        sa->a_c0    = CONST;
        sa->a_i14   = word_AE11;		/* long	  */
        sa->a_i12   = 0;
        sa->a_l15.l = l2;
        break;

      case GADDR:
        if(sa->a_i12 == 0) {
          if(1 < (unsigned)sa->a_i14->b_nelem) {
            sa->a_i12 = sa->a_i14->b_refl;
            sa->a_i14 = sa->a_i14->b_type;
          }
        }
        sub_385B(sa);
        break;

      case LPAREN:
      case MUL_U:
        sub_37ED(sa);
        break;

      case DOT:
        if(p2a->a_c0 == TYPEOP) {	/* m9: */
          l1b = p2a->a_i14;
          sub_36E0(sa);
          sub_36E0(p2a);
          sa           = p3a;
          sa->a_i14    = l1b;
          p3a->a_l15.l = *((int)sa->a_l15.wi[0] + l1b->b_memb + 1);
          break;
        }
        l1b = *(p3a->a_l15.ii[0] + sa->a_i14->b_memb + 1);	/* assigning to "struct aaa *" from "int" */
        sa->a_i14    = l1b->b_type;
        sa->a_i12    = l1b->b_refl;
        p3a->a_l15.l = l1b->b_i11;
        p3a->a_i14   = word_AF1D;		/* x      */
        if((l1b->b_c3 & 0x10) == 0) break;
        p2a              = sub_3712();
        *p2a             = *sa;
        p2a->a_l15.wi[0] = sa;
        sa               = p2a;
        sa->a_c0         = BFIELD;
        sa->a_l15.vi[1]  = l1b;
        break;

      case COLON_S:
        sa->a_i14 = word_AED9;			/* char   */
        sa->a_i12 = 1;
        break;

      case CONV:
      case SCOLON:
      case QUEST:
        sa->a_i14 = sa->a_l15.wi[1]->a_i14;
        sa->a_i12 = sa->a_l15.wi[1]->a_i12;
        break;
    }
#ifdef DEBUG
    printf("\tsub_43EF\t\tReturn %x\n", sa);
#endif
    return sa;
}

/* End of file sub_43EF.c  */


/*
 * File - sub_46F7.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_46F7 OK++     Used in: sub_2D09, sub_47B2, sub_4FCE
 *			      sub_54B6
 *********************************************************/
uchar sub_46F7(long p1) {
    uchar l1;

#ifdef DEBUG
    printf("\tsub_46F7(%lu)\n", p1);
#endif

    if(((p1 & ((-1) + p1)) != 0) || (p1 < 1)) return 0;
    l1 = 0;
    while((p1 >>= 1) != 0) l1++;
    return (l1 + 1);
}

/* End of file sub_46F7.c  */


/*
 * File - sub_475C.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_475C OK++    Used in: sub_808,  sub_E43,  sub_17E0,
 *			     sub_19C1, sub_1B0C, sub_2BD0,
 *			     sub_3DC9, sub_3EAA, sub_43EF,
 *			     sub_475C, sub_4DA3, sub_4FA8,
 *			     sub_508A, sub_54B6
 *********************************************************/
void sub_475C(register struct aaa * sa) {
    int loc;

#ifdef DEBUG
    printf("\tsub_475C(%x)\n", sa);
#endif

    if((loc = dopetab[sa->a_c0] & 0xC) != 0) {
      sub_475C(sa->a_l15.wi[0]);
      if(loc == 8) {
        sub_475C(sa->a_l15.wi[1]);
      }
    }
    sub_36E0(sa);
#ifdef DEBUG
    printf("\tsub_475C\t\tReturn\n");
#endif
}

/* End of file sub_475C.c  */


/*
 * File - sub_47B2.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_47B2 OK+				Used in: sub_1F4B
 *********************************************************/
char sub_47B2(register struct aaa * sa, int p2) {
    long l1;

#ifdef DEBUG
    printf("\tsub_47B2(%x, %d)\n", sa, p2);
#endif

    switch (p2-1) {					/* m1:  */
      case MUL_U - 1:
        sa = sa->a_l15.wi[1];				/* m2:  loc_47DE */
      case T_SCOLON - 1:
        if(sa->a_l15.l >= 1) {				/* m3:  loc_47E7 */
          if(sa->a_l15.l < 3) return 1;
        }
        return 0;
      case RPAREN - 1:
        sa = sa->a_l15.wi[0];				/* m5:  loc_4821 */
      case MOD - 1:
        if(nodesize(sa) == 2) {				/* m6:  loc_482A */
m7:       if((char)sub_3968(sa) == 0) return 1;
        }
        return 0;
      case BAND - 1:
        if(sub_14F3(sa) != REG_F) goto m12;		/* m9:  loc_4846 */
        return 0;
      case MUL - 1:
        sa = sa->a_l15.wi[0];				/* m11: loc_4856 */
      case DOLLAR_U - 1:
m12:	if(nodesize(sa) == 4) return 0;			/* m12: loc_485F */
        goto m7;
      case SCOLON - 1:
        sa = sa->a_l15.wi[0];				/* m13: loc_486A */
      case DOLLAR-1:
        return sub_3968(sa);				/* m14: loc_4873 */
      case ADD - 1:
        if(sa->a_l15.bc[0] == 8) return 1;		/* m16: loc_487C */
        if(sa->a_l15.bc[0] == 9) return 1;
        return 0;
      case INCR - 1:
        l1 = sub_2C5E(sa, sa->a_l15.l);			/* m17: loc_4887 */
        if(l1 < (long)0xffffff80) return 0;
        if(l1 < 0x7d) return 1;
        return 0;
      case COLON_U - 1:
        if(sa->a_l15.l < 1) return 0;			/* m19: loc_48E0 */
        if(sa->a_l15.l < 5) return 1;
        return 0;
      case COLON_S - 1:
        l1 = sa->a_l15.l;				/* m20: loc_4910 */
        if(sub_14F3(sa) != REG_L) goto m21;
        if((l1 & 1<<(nodesize(sa)<<3)) == 0) goto m21;
        l1 |= ((-1) - (unsigned)((int)(1<<(nodesize(sa)<<3)) - 1));
m21:	if(((uchar)l1 & 0x80) == 0) return 0;
        if(l1 >= (long)0xFFFFFFFC)  return 1;
        return 0;
      case LPAREN - 1:
        sa = sa->a_l15.wi[1];				/* m22: loc_49AA */
      case HASHSIGN - 1:
        if(nodesize(sa) != 1) return 0;			/* m23: loc_49B3 */
        if((char)sub_3968(sa) != 0) return 0;
        return 1;
      case MINUS_U - 1:
        if(nodesize(sa) != 4) return 0;			/* m24: loc_49CD */
m25:	if(sub_14F3(sa) != REG_F) goto m27;
        return 0;
      case COMMA - 1:
        if(nodesize(sa) == 2) goto m25;			/* m26: loc_49EA */
        return 0;
m27:	if(sub_14F3(sa->a_l15.wi[0]) == REG_F) return 0;     /* loc_49FB */
        if(sub_14F3(sa) != REG_L) {
m28:	  if(sub_14F3(sa->a_l15.wi[0]) != REG_L) return 0;   /* loc_4A15 */
        }
        return 1;
      case LT - 1:
        if(sa->a_l15.l == 0) return 1;			/* m29: loc_4A29 */
        return 0;
      case CONV - 1:					/* m31: loc_4A3F */
        if(nodesize(sa) == 4) {
m32:	  if(sub_14F3(sa) == REG_A) {
            if(sub_14F3(sa->a_l15.wi[0]) == REG_A) return 1;
          }
        }
        return 0;
      case SUB - 1:
        if(nodesize(sa) == 2) goto m32;			/* m34: loc_4A5F */
        return 0;
      case PLUS_U - 1:
        if(1 == sa->a_l15.l) return 1;			/* m36: loc_4A7B */
        return 0;
      case NOT - 1:
        return (uchar)sub_46F7(sa->a_l15.wi[1]->a_l15.l);	/* m38: loc_4A9C */
      case NEQL - 1:
        return (uchar)sub_46F7(-1 - sa->a_l15.wi[1]->a_l15.l);	/* m40: loc_4AB7 */
      case COLON - 1:
        if(nodesize(sa) == 4) goto m45;			/* m41: loc_4ADB */
        return 0;
      case DECR - 1:
        if(nodesize(sa) == 2) goto m45;			/* m43: loc_4AEC */
        return 0;
      case GADDR - 1:
        if(nodesize(sa) != 1) return 0;			/* m44: loc_4AF7 */
m45:	if(sub_14F3(sa) != REG_A) {
          if(sub_14F3(sa) != REG_L) return 0;
        }
        if(sub_14F3(sa->a_l15.wi[0]) != REG_F) return 0; /* m46: loc_4B19 */
        return 1;
      case DIV - 1:
        if(nodesize(sa->a_l15.wi[0]) == 1) goto m51;	/* m47: loc_4B2A */
        return 0;
      case DOT_DOT - 1:
        if(nodesize(sa->a_l15.wi[0]) == 2) goto m51;	/* m49: loc_4B40 */
        return 0;
      case DOT - 1:
        if(nodesize(sa->a_l15.wi[0]) != 4) return 0;	/* m50: loc_4B50 */
m51:	if(sub_14F3(sa) != REG_F) return 0;
        if(sub_14F3(sa->a_l15.wi[0]) == REG_A) return 1;
        goto m28;
      case LAND - 1:
        if(sub_14F3(sa) == REG_F) return 1;		/* m52: loc_4B7D */
    }
    return 0;
}

/* End of file sub_47B2.c  */


/*
 * File - sub_4B89.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_4B89 OK+		      Used in: sub_4C12, sub_54B6
 *
 * Minor differences in the generated code.
 * Function is assigned the uchar type to avoid casting
 * type when it is called in other functions and generating
 * code corresponding to binary image.
 * Function is logically correct.
 *********************************************************/
uchar sub_4B89(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_4B89(%x)\n", sa);
#endif

    if((dopetab[sa->a_c0] & 0x10) == 0) { /* Any operator except "#", "..", "CONST" */
      if((sa->a_c0 != GADDR) || (sa->a_l15.wi[0]->a_c0 != IDOP)) {
        if(sa->a_c0 == ADD) {
          if(sa->a_l15.wi[1]->a_c0 == CONST) {
            if(sub_4B89(sa->a_l15.wi[0]) != 0) {
              return 1;
            }
          }
        }
        return 0;	/* m2: */
      }
    }
    return 1;		/* m3: */
}

/* End of file sub_4B89.c  */


/*
 * File - sub_4BE5.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_4BE5 OK++			Used in: sub_54B6
 *********************************************************/
int sub_4BE5(register struct aaa * sa) {


#ifdef DEBUG
    printf("\tsub_4BE5(%x)\n", sa);
#endif

    if(sa->a_c0 != CONST) goto m1;
    if(sa->a_l15.l != 0)  goto m1;
    return 1;
m1: return 0;
}

/*********************************************************
 * sub_4C12 OK++			Used in: sub_54B6
 *********************************************************/
int sub_4C12(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_4C12(%x)\n", sa);
#endif

    if(sa->a_c0 == GADDR) {
      if(sa->a_l15.wi[0]->a_c0 == IDOP) return 1;
    }
    if((dopetab[sa->a_c0] & 0x10) != 0) return 0; /* if "#", "..", "CONST"  */
    if(sub_4B89(sa) != 0) return 1;
    return dopetab[sa->a_c0] & 0xF;
}

/* End of file sub_4BE5.c  */


/*
 * File - sub_4C6D.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_4C6D OK+				Used in: sub_3CDF
 *********************************************************/
char sub_4C6D(struct aaa * p1a) {

#ifdef DEBUG
    printf("\tsub_4C6D(%x)\n", p1a);
#endif

    if(p1a->a_l15.wi[0]->a_c0 == USEREG) return 1;
    return 0;
}

/* End of file sub_4C6D.c  */


/*
 * File - sub_4C8B.c Created 09.03.2019 Last Modified 31.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_4C8B OK++			Used in: sub_54B6
 *********************************************************/
struct aaa * sub_4C8B(register struct aaa * sa) {
    struct aaa * l1;

#ifdef DEBUG
    printf("\tsub_4C8B(%x)\n", sa);
#endif

    l1 = sa->a_l15.wi[0];
    if(sa->a_l15.wi[0]->a_c0 == NOT) {
      l1 = l1->a_l15.wi[0];
      sub_36E0(sa->a_l15.wi[0]);
      sub_36E0(sa);
      return l1; 
    } 
    if((dopetab[l1->a_c0] & 0x12C) == '(') {
      sub_36E0(sa);
      l1->a_c0 = sub_605E(l1->a_c0);
      return l1; 
    } 
    if((dopetab[l1->a_c0] & 0x20) != 0) {
      l1->a_l15.wi[0] = sub_43EF(NOT, l1->a_l15.wi[0], (struct aaa *)0);
      l1->a_l15.wi[1] = sub_43EF(NOT, l1->a_l15.wi[1], (struct aaa *)0);
      sub_36E0(sa);
      l1->a_c0 = (l1->a_c0 == LAND) ? LOR : LAND;
      return l1; 
    }	
    return sa;
}

/*********************************************************
 * sub_4DA3 OK++			Used in: sub_54B6
 *********************************************************/
struct aaa * sub_4DA3(register struct aaa * sa) {
    struct aaa * l1a;

#ifdef DEBUG
    printf("\tsub_4DA3(%x)\n", sa);
#endif

    if((char)sa->a_l15.wi[0]->a_i12 == 1) {
      l1a        = sub_415E(sa->a_l15.wi[0]->a_i10);
      l1a->a_i14 = sa->a_i14;
      l1a->a_i12 = sa->a_i12;
      sub_475C(sa);
      sub_385B(l1a);
      sa          = sub_3712();
      *sa         = *l1a;
      sa->a_c0    = USEREG;
      sa->a_l15.l = 8;
      sa          = sub_43EF(ADD, sa, l1a);
      return sub_43EF(INCR, sa, 0);
    }
    if((char)sa->a_l15.wi[0]->a_i12 == 2) {
      sa->a_c0    = USEREG;
      sa->a_l15.l = (int)sa->a_l15.wi[0]->a_i11;
    }
    return sa;
}

/*********************************************************
 * sub_4E8D OK++ 			Used in: sub_54B6
 *********************************************************/
struct aaa * sub_4E8D(register struct aaa * sa) {
    struct aaa * l1a;

#ifdef DEBUG
    printf("\tsub_4E8D(%x)\n", sa);
#endif

    if((dopetab[(l1a = sa->a_l15.wi[0])->a_c0] & 0x1000) != 0) {
      l1a->a_i14      = sa->a_i14;
      l1a->a_i12      = sa->a_i12;
      sa->a_l15.wi[0] = l1a = sub_43EF(GADDR, l1a, 0);
    } else {
      l1a       = sub_3712();
      *l1a      = *sa;
      l1a->a_c0 = TYPEOP;
      sub_385B(l1a);
      sa->a_l15.wi[0] = sub_43EF(CONV, sub_43EF(GADDR, sa->a_l15.wi[0], 0), l1a);
    }
    sa->a_i14              = l1a->a_i14;
    sa->a_i12              = l1a->a_i12;
    sa->a_l15.wi[1]->a_i12 = sa->a_i12;
    sa->a_l15.wi[1]->a_i14 = sa->a_i14;
    sa->a_c0               = ADD;
    return sub_43EF(MUL_U, sa, 0);
}

/*********************************************************
 * sub_4FA8 OK++			Used in: sub_54B6
 *********************************************************/
struct aaa * sub_4FA8(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_4FA8(%x)\n", sa);
#endif

    sub_475C(sa->a_l15.wi[1]);
    sub_36E0(sa);
    return sa->a_l15.wi[0];
}

/* End of file sub_4C8B.c  */


/*
 * File - sub_4FCE.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_4FCE OK+				Used in: sub_54B6
 *
 * Compiler generates identical code from restored source
 * program in C, however, location of branches associated
 * with case constants is different from original.
 * This does not affect the function.
 *********************************************************/
struct aaa * sub_4FCE(register struct aaa * sa) {

#ifdef DEBUG
    printf("\tsub_4FCE(%x)\n", sa);
#endif
 
    switch (sa->a_c0) {
      case MOD:
        sa->a_c0 = BAND;
        sa->a_l15.wi[1]->a_l15.l--;
        return sa;
      case MUL:
        sa->a_c0 = LSHIFT;
        break;
      case DIV:
        if(sub_14F3(sa) != REG_L) return sa;
        sa->a_c0 = RSHIFT;
        break;
      case ASMOD:
        sa->a_c0 = ASAND;
        sa->a_l15.wi[1]->a_l15.l--;
        return sa;
      case ASMUL:
        sa->a_c0 = ASLSHIFT;
        break;
      case ASDIV:
        if(sub_14F3(sa) != REG_L) return sa;
        sa->a_c0 = ASRSHIFT;
        break;
    }
    byte_B013 = 1;
    sa->a_l15.wi[1]->a_l15.l = sub_46F7(sa->a_l15.wi[1]->a_l15.l) - 1;
    return sa;
}

/* End of file sub_4FCE.c  */


/*
 * File - sub_508A.c Created 09.03.2019 Last Modified 31.05.2020
 */

#include "stdio.h"
#include <string.h>
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_508A OK++			Used in: sub_54B6
 *********************************************************/
struct aaa * sub_508A(register struct aaa * sa) {
    struct aaa * l1a;
    struct aaa * l2a;
    char	 buf[15];
    long	 l3;

#ifdef DEBUG
    printf("\tsub_508A(%x)\n", sa);
#endif

    if(sub_14F3(sa) == REG_F) {
      if(sa->a_l15.wi[0]->a_c0 == CONST) {
        l3 = sa->a_l15.wi[0]->a_l15.l;
        sub_36E0(sa->a_l15.wi[0]);
        sub_36E0(sa->a_l15.wi[1]);
        sprintf(buf, "%ld", l3);
        sa->a_l15.ci[0] = (char *)allocmem(strlen(buf)+1); /* create string */
        strcpy(sa->a_l15.ci[0], buf);
        sa->a_l15.ii[1] = sub_174C(); /* word_AE0F++ */
        sa->a_c0 = FCONST;
        return sa;						/* m1:  */
      }
    }
    if((dopetab[(l1a=sa->a_l15.wi[0])->a_c0] & 0x1000) != 0) {	/* m2:  */
      if(nodesize(l1a) >= nodesize(sa)) {
        if(sub_14F3(sa) != REG_F) {
          if(sub_14F3(l1a) != REG_F) { 
            l1a->a_i14 = sa->a_i14;
            l1a->a_i12 = sa->a_i12;
            sub_36E0(sa->a_l15.wi[1]);
            sub_36E0(sa);					/* m3:  */
            return l1a;
          }
        }
      }
    }
    if((char)sub_6246(sa, l1a) != 0) {				/* m5:  */
      sub_475C(sa->a_l15.wi[1]);
      l1a->a_i14 = sa->a_i14;
      l1a->a_i12 = sa->a_i12;
      sub_36E0(sa);
      return l1a;
    }
    if(nodesize(l1a) < nodesize(sa)) return sa;			/* m6:  */
    if(l1a->a_c0 == CONV) {
      if(nodesize(l1a->a_l15.wi[0]) >= nodesize(sa)) {
        if(sub_6246(sa, l1a->a_l15.wi[0]) != 0) goto m7;
        if(sub_14F3(sa) == sub_14F3(l1a)) {
          if(sub_14F3(sa) == sub_14F3(l1a->a_l15.wi[0])) {
m7:         sa->a_l15.wi[0] = l1a->a_l15.wi[0];
            sub_36E0(l1a->a_l15.wi[1]);
            sub_36E0(l1a);
            return sa;
          }
        }
      }
    }
    if((dopetab[l1a->a_c0] & 0xC00) == 0) return sa; 		/* m8:  */
    if(sub_14F3(l1a) == REG_F) return sa;
    if((dopetab[l1a->a_c0] & 0x400) != 0) {
      if(l1a->a_l15.wi[0]->a_c0 != CONV) return sa;
      if(nodesize(l1a->a_l15.wi[0]->a_l15.wi[0]) >= nodesize(l1a)) return sa;
    }
    l2a = sub_43EF(CONV, l1a->a_l15.wi[0], sa->a_l15.wi[1]);	/* m9:  */
    *sa = *sa->a_l15.wi[1];
    if((dopetab[l1a->a_c0] & 8) != 0) {
      sa = sub_43EF(CONV, l1a->a_l15.wi[1], sa);
    } else {
      sub_36E0(sa);						/* m10: */
      sa = 0;	  
    }
    l2a = sub_43EF((uchar)l1a->a_c0, l2a, sa);			/* m11: */
    sub_36E0(l1a);
    return l2a;
}

/*********************************************************
 * sub_53EE  OK++			Used in: sub_54B6
 *********************************************************/
struct aaa * sub_53EE(register struct aaa * sa) {
    struct aaa * l1a;

#ifdef DEBUG
    printf("\tsub_53EE(%x)\n", sa);
#endif

    if((dopetab[(l1a = sa->a_l15.wi[0])->a_l15.wi[0]->a_c0] & 0x1000) != 0) {
      l1a        = l1a->a_l15.wi[0];
      l1a->a_i14 = sa->a_i14;
      l1a->a_i12 = sa->a_i12;
      sub_36E0(sa->a_l15.wi[0]);
      sub_36E0(sa);
      return l1a;
    }
    sa->a_c0        = CONV;
    sa->a_l15.wi[1] = l1a;
    sa->a_l15.wi[0] = l1a->a_l15.wi[0];
    l1a->a_c0       = TYPEOP;
    l1a->a_i14      = sa->a_i14;
    l1a->a_i12      = sa->a_i12;
    byte_B013       = 1;
    return sa;
}

/* End of file sub_508A.c  */


/*
 * File - sub_54B6.c Created 09.03.2019 Last Modified 31.05.2020
 */

#include "stdio.h"
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_54B6 - optim: Out of memory	Used in: sub_600E
 *********************************************************/
struct aaa * sub_54B6(register struct aaa * sa) {
    struct aaa  * l1a;
    struct aaa  * l2a;
    int		  l3;
    unsigned long l4;

#ifdef DEBUG
    printf("\tsub_54B6(%x)\n", sa);
#endif

    l3 = dopetab[sa->a_c0] & 0xC;
    if(l3 != 0) {
      sa->a_l15.wi[0] = sub_54B6(sa->a_l15.wi[0]);
    }
    if(l3 == 8) sa->a_l15.wi[1] = sub_54B6(sa->a_l15.wi[1]);		/* m1: */
    if((dopetab[sa->a_c0] & 0x40) != 0) {				/* m2: */
      if(sub_4C12(sa->a_l15.wi[0]) < sub_4C12(sa->a_l15.wi[1])) {
	byte_B013       = 1;
	l1a             = sa->a_l15.wi[0];
	sa->a_l15.wi[0] = sa->a_l15.wi[1];
	sa->a_l15.wi[1] = l1a;
      }
      if((dopetab[sa->a_c0] & 0x2000) != 0) { 				/* m3: */
	if(sa->a_c0 == sa->a_l15.wi[0]->a_c0) {
	  if(sub_4B89(sa->a_l15.wi[1]) != 0) {
	    if(sub_4B89((l1a = sa->a_l15.wi[0])->a_l15.wi[1]) != 0) {
	      byte_B013        = 1;
	      sa->a_l15.wi[0]  = l1a->a_l15.wi[1];
	      l1a->a_l15.wi[1] = sa;
	      sa               = l1a;
	      goto m5;
	    }
          }
          if(sub_4C12(sa->a_l15.wi[0]->a_l15.wi[1]) < sub_4C12(sa->a_l15.wi[1])) { /* m4: */
	    byte_B013       = 1;
	    l1a             = sa->a_l15.wi[1];
	    sa->a_l15.wi[1] = sa->a_l15.wi[0]->a_l15.wi[1];
	    sa->a_l15.wi[0]->a_l15.wi[1] = l1a;
	  }
	}
      }
    }
m5: if((dopetab[sa->a_c0] & 0xC00) == 0x800) {
      if(sa->a_l15.wi[0]->a_c0 == CONV) {
        if(nodesize(sa->a_l15.wi[0]->a_l15.wi[0]) < nodesize(sa)) {
          if(sub_60A8(sa->a_l15.wi[1], sa->a_l15.wi[0]->a_l15.wi[0]) != 0) {
            l2a                    = sa->a_l15.wi[0];
            sa->a_l15.wi[0]        = l2a->a_l15.wi[0];
            sa->a_i14              = sa->a_l15.wi[0]->a_i14;
            sa->a_i12              = sa->a_l15.wi[0]->a_i12;
            sa->a_l15.wi[1]->a_i14 = sa->a_i14;
            sa->a_l15.wi[1]->a_i12 = sa->a_i12;
            l2a->a_l15.wi[0]       = sa;
            sa = l2a;
          }
        }
      }
    }
    if((dopetab[sa->a_c0] & 0x420) == 0x420) {				/* m6: */
      l1a = sa->a_l15.wi[0];
      if(sa->a_l15.wi[0]->a_c0 == CONV) {
        if(nodesize(l1a->a_l15.wi[0]) != 0) {
          if(nodesize(l1a->a_l15.wi[0]) < nodesize(l1a)) {
            if(sa->a_l15.wi[1]->a_c0 == CONST) {
              if((sub_14F3(l1a) == REG_A) || (sub_14F3(l1a->a_l15.wi[0]) == REG_L)) {
                if(sub_62BE(sa->a_l15.wi[0], sa->a_l15.wi[1]) != 0) {	/* m7: */
                  sub_36E0(sa->a_l15.wi[0]);
                  sub_36E0(sa->a_l15.wi[0]->a_l15.wi[1]);
                  sa->a_l15.wi[0]        = sa->a_l15.wi[0]->a_l15.wi[0];
                  sa->a_l15.wi[1]->a_i14 = sa->a_l15.wi[0]->a_i14;
                  sa->a_l15.wi[1]->a_i12 = sa->a_l15.wi[0]->a_i12;
                  goto m10;
                }
                word_B015 =  "mismatched comparision";			/* m8: */
                goto m10;
              }
            }
            if(sa->a_l15.wi[1]->a_c0 == CONV) {				/* m9: */
              if(sub_6246(sa->a_l15.wi[0]->a_l15.wi[0], sa->a_l15.wi[1]->a_l15.wi[0]) != 0) {
                l1a             = sa->a_l15.wi[0];
                sa->a_l15.wi[0] = l1a->a_l15.wi[0];
                sub_36E0(l1a->a_l15.wi[1]);
                sub_36E0(l1a);
                l1a             = sa->a_l15.wi[1];
                sa->a_l15.wi[1] = l1a->a_l15.wi[0];
                sub_36E0(l1a->a_l15.wi[1]);
                sub_36E0(l1a);
              }
            }
          }
        }
      }
    }	/* Ok */
m10:switch(sa->a_c0) {
      case NOT:
	return sub_4C8B(sa); /* goto m11; */				/* m13 */
      case GADDR:
	if(sa->a_l15.wi[0]->a_c0 != MUL_U) return sa;			/* m47 */
m48:    return sub_53EE(sa); /* goto m11; */
      case MUL:
      case DIV:
      case ASMUL:
      case ASDIV:
        if(sa->a_l15.wi[1]->a_c0 == CONST) {				/* m34 */
          if(sa->a_l15.wi[1]->a_l15.l == 1) goto m30;
        }
      case MOD:
      case ASMOD:
        if(sa->a_l15.wi[1]->a_c0 == CONST) {				/* m35 */
          if(sub_46F7(sa->a_l15.wi[1]->a_l15.l) != 0) {
            return sub_4FCE(sa); /* goto m11; */
          }
        }
      case BAND:
      case ASAND:
        if(sa->a_l15.wi[1]->a_c0 != CONST) goto m41;			/* m36 */
        if(sa->a_l15.wi[1]->a_l15.l != 0)  goto m41;
        switch(sa->a_c0) {
          case MOD:
          case DIV:
          case ASMOD:
	    warning("Division by zero");
	    return sa; /* goto m18; */
          case BAND:
          case MUL:
            sub_475C(sa->a_l15.wi[0]);
            sub_475C(sa->a_l15.wi[1]);
            sa->a_c0    = CONST;
            sa->a_l15.l = 0;
            return sa; /* goto m18; */
          case ASAND:
          case ASMUL:
            sa->a_c0 = ASSIGN;
            return sa; /* goto m18; */
          case ASDIV:
m41:        l4 = (nodesize(sa) >= 4) ? (long)(-1) : ((long)1<<(nodesize(sa)*8)) + 0xffffffff;
            if(sa->a_c0 != BAND) {
              if(sa->a_c0 != ASAND) return sa;	/* goto m18; */
            }
            if(sa->a_l15.wi[1]->a_c0 != CONST) return sa;		/* m44: */
            if(l4 != (sa->a_l15.wi[1]->a_l15.l & l4)) return sa;
            goto m30;
	}
      case CONV:
        return sub_508A(sa);						/* m45 */
        /* goto m11; */
      case MUL_U:
        if(sa->a_l15.wi[0]->a_c0 != GADDR) return sa;			/* m49 */
        switch((l1a = sa->a_l15.wi[0]->a_l15.wi[0])->a_c0) {
          case LPAREN:
          case ASSIGN:
          case QUEST:
            return sa; /* goto m18; */
        }
        goto m48;
      case PLUS_U:
        sub_36E0(sa);							/* m46 */
        sa = sa->a_l15.wi[0];
        return sa; /* goto m18; */
      case DOT:
        return sub_4E8D(sa);	/* goto m11; */				/* m12 */
      case LT:
      case GEQ:
        if(sub_14F3(sa->a_l15.wi[0]) == REG_L) {			/* m14 */
          if(sub_4BE5(sa->a_l15.wi[0]) != 0) {
            word_B015 = "degenerate unsigned comparision";
            sub_475C(sa);
            sa = sub_415E((sa->a_c0 == GEQ) ? (long)1 : (long)0);
          }
        }
        return sa;	/* goto m18: */
      case LEQ:
      case GT:
        if(sub_14F3(sa->a_l15.wi[0]) == REG_L) {			/* m19: */
          if(sub_4BE5(sa->a_l15.wi[1]) != 0) {
            sa->a_c0 = (sa->a_c0 == GT) ? (char)NEQL : (char)EQL;
            return sa; /* goto m18; */
          }
        }
        if(sa->a_c0 == CONST) {						/* m23: */
          sa->a_l15.wi[1]->a_l15.l += 1;
          sa->a_c0 = (sa->a_c0 == GT) ? (char)GEQ : (char)LT;
        } else {
          l1a             = sa->a_l15.wi[0];				/* m25: */
          sa->a_l15.wi[0] = sa->a_l15.wi[1];
          sa->a_l15.wi[1] = l1a;
          sa->a_c0        = (sa->a_c0 != GT) ? (char)GEQ : (char)LT;
        }
        return sa; /* goto m18; */
      case ASEOR:
      case BOR:
        if(sa->a_l15.wi[1]->a_c0 == CONST) {				/* m27 */
          if(sa->a_l15.wi[1]->a_l15.l == (-1)) {
            sub_475C(sa->a_l15.wi[0]);
            sub_36E0(sa);
            return sa->a_l15.wi[1];
          }
        }
      case ADD:
      case SUB:
      case LSHIFT:
      case ASADD:
      case ASSUB:
      case ASLSHIFT:
      case ASRSHIFT:
      case RSHIFT:
        if(sa->a_l15.wi[1]->a_c0 == CONST) {				/* m28: */
          if(sa->a_l15.wi[1]->a_l15.l == 0) {
m30:        return sub_4FA8(sa); /* goto m11; */
          }
        }
        if((dopetab[sa->a_c0] & 0x80) != 0) {				/* m31: */
          if(nodesize(sa->a_l15.wi[1]) != 1) {
            l1a = sub_3712();
/*          asdf = 1;	*/
            *((sub_14F3(sa->a_l15.wi[1]) == REG_L) ?
            (int*)word_AE53 :		/* Pointers "int*" are not  */	/* uchar  */
            (int*)word_AED9) =		/* true, but generated code */ 	/* char   */
            &(l1a->a_i14);		/* is logically correct     */
            l1a->a_c0 = TYPEOP;
            sa->a_l15.wi[1] = sub_43EF(CONV, sa->a_l15.wi[1], l1a);
          }
        }
        return sa; /* goto m18; */
    }
    if(sa->a_c0 != IDOP) return sa; /* goto m18; */
    return sub_4DA3(sa);
}

/* End of file sub_54B6.c  */


/*
 * File - sub_5CF5.c Created 09.03.2019 Last Modified 17.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_5CF5 OK+			Used in: sub_406, sub_17E0
 *
 * Compiler generates identical code, however, location
 * of branches associated with case constants is different
 * from original. This does not affect the function.
 *********************************************************/
void sub_5CF5(register struct bbb * sb, int p2) {

#ifdef DEBUG
    printf("\tsub_5CF5(%x, %d)\n", sb, p2);
#endif

    switch(sb->b_c13) {
      case 1:
	if(sub_61AA(sb, p2) == 0) {
	  array_AE13[lvlidx] -= sb->b_size;
	  if((sb->b_i11 = array_AE13[lvlidx]) < 0xFF80) {
	    if(sb->b_size >= 4) {
	      warning("%s: large offset", sb->b_name);
	    }
	  }
	}
	break;
      case 3:
      case 4:
	sub_C57(sb);
	break;
      case 5:
	sb->b_i11 = array_AE97[lvlidx];
	array_AE97[lvlidx] += sb->b_size;
	if(sb->b_size == 1) {
	  switch(sb->b_type->b_class) {
	    case SDECL:
	    case UDECL:
	      break;
	    default:
	      array_AE97[lvlidx]++;
	  }
	}
	if((char)sub_61AA(sb, p2) == 0) sb->b_c13 = 1;
    }
}

/* End of file sub_5CF5.c  */


/*
 * File - sub_5DF6.c Created 09.03.2019 Last Modified 31.05.2020
 */

#include "stdio.h"
#include <string.h>
#include "cgen.h"

/*********************************************************
 * sub_5DF6 OK++			Used in: sub_600E
 *********************************************************/
struct aaa * sub_5DF6(register struct aaa * sa) {
    char   l1;
    char * l2;

#ifdef DEBUG
    printf("\tsub_5DF6(%x)\n", sa);
#endif

    l1 = dopetab[sa->a_c0] & 0xC;
    if(l1 == 8) sa->a_l15.wi[1] = sub_5DF6(sa->a_l15.wi[1]);
    if(l1 != 0) sa->a_l15.wi[0] = sub_5DF6(sa->a_l15.wi[0]);

    switch (sa->a_c0) {
      case SUB:
      case ASSUB:
        if(sa->a_l15.wi[1]->a_c0 == CONST) {
          sa->a_l15.wi[1]->a_l15.l = 0 - sa->a_l15.wi[1]->a_l15.l;
        } else {
          sa->a_l15.wi[1] = sub_43EF(MINUS_U, sa->a_l15.wi[1], 0);
        }
        sa->a_c0 = (sa->a_c0 == SUB) ? ADD : ASADD;
        break;
      case MINUS_U:
        if(sa->a_l15.wi[0]->a_c0 == MINUS_U) {
          sub_36E0(sa);
          sa = sa->a_l15.wi[0];
          sub_36E0(sa);
          sa = sa->a_l15.wi[0];
        }
        if(sa->a_l15.wi[0]->a_c0 == FCONST) {
          sub_36E0(sa);
          sa = sa->a_l15.wi[0];
          l2 = (char *)allocmem(strlen(sa->a_l15.ci[0])+2);
          strcat(strcpy(l2, "-"), sa->a_l15.ci[0]);
          sub_7028((struct ptr *)sa->a_l15.wi[0]);
          sa->a_l15.ci[0] = l2;
        }
    }
#ifdef DEBUG
    printf("\tsub_5DF6\t\tReturn %x\n", sa);
#endif
    return sa;
}

/* End of file sub_5DF6.c  */


/*
 * File - sub_5F52.c Created 09.03.2019 Last Modified 27.06.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_5F52 OK++			Used in: sub_600E
 *********************************************************/
struct aaa * sub_5F52(register struct aaa * sa) {
    char         l1;
    struct aaa * l2;

#ifdef DEBUG
    printf("\tsub_5F52(%x)\n", sa);
#endif

    l1 = dopetab[sa->a_c0] & 0xC;
    if(l1 == 8) sa->a_l15.wi[1] = sub_5F52(sa->a_l15.wi[1]);
    if(l1 != 0) sa->a_l15.wi[0] = sub_5F52(sa->a_l15.wi[0]);

    switch (sa->a_c0) {
      case ADD:
        if(sa->a_l15.wi[0]->a_c0 == MINUS_U) {	/* m4: */
          l2              = sa->a_l15.wi[0];
          sa->a_l15.wi[0] = sa->a_l15.wi[1];
          sa->a_l15.wi[1] = l2;
        }
      case ASADD:
        if(sa->a_l15.wi[1]->a_c0 == MINUS_U) {	/* m5 */
          sub_36E0(sa->a_l15.wi[1]);
          sa->a_l15.wi[1] = sa->a_l15.wi[1]->a_l15.wi[0];
          sa->a_c0 = (sa->a_c0 == ASADD) ? ASSUB : SUB;
        }
    }
#ifdef DEBUG
    printf("\tsub_5F52\t\tReturn %x\n", sa);
#endif
    return sa;
}

/* End of file sub_5F52.c  */


/*
 * File - sub_600E.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_600E OK++     Used in: sub_793,  sub_808,  sub_E43,
 *                            sub_17E0, sub_19C1, sub_1B0C,
 *			      sub_3DC9
 *********************************************************/
struct aaa * sub_600E(register struct aaa * sa) {
#if 0
    int l1; /* Not used */
#endif

#ifdef DEBUG
    struct aaa * tmp;
    printf("\tsub_600E(%x)\n", sa);
#endif

    word_B015 = 0;
    sa = sub_5DF6(sa);
#if 0
    l1 = 0; 		/* Not used, forgot to exclude */
#endif
    do {
      byte_B013 = 0;
/*
      Excluded part optimization code
      present in the DOS version (3.06)
*/
      sa = sub_3EAA(sub_54B6(sa));
    } while (byte_B013 != 0);

    if(word_B015 != 0) {
      warning(word_B015);
    }
#ifdef DEBUG
    tmp = sub_5F52(sa);
    printf("\tsub_600E\t\t Return %x\n", tmp);
    return tmp;
#else
    return sub_5F52(sa);
#endif
}

/* End of file sub_600E.c  */



/*
 * File - sub_605E.c Created 09.03.2019 Last Modified 26.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_605E OK+				Used in: sub_4C8B
 *
 * Compiler generates identical code, however, location
 * of branches associated with case constants is different
 * from original. This does not affect the function.
 *********************************************************/

int sub_605E(int op) {

#ifdef DEBUG
    printf("\tsub_605E(%d)\n", op);
#endif

    switch(op) {
      case NEQL:  break;
      case LT: 	  return GEQ;
      case LEQ:   return GT;
      case EQL:   return NEQL;
      case GT:    return LEQ;
      case GEQ:   return LT;
    }
    return EQL;
}

/* End of file sub_605E.c  */


/*
 * File - sub_60A8.c Created 09.03.2019 Last Modified 31.01.2021
 */

#include "stdio.h"
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_60A8 OK+				Used in: sub_54B6
 *
 * Added the r_bc variable to preserve the logical
 * behavior of the function. This function was optimized
 * manually in assembly language. In places with forced 
 * type casting in the original binary program image, the 
 * value is returned in the HL register pair.
 *
 * Generated code is different, but does not affect the
 * program logic. This function is boolean and only returns
 * 0 or 1.
 *********************************************************/
char sub_60A8(register struct aaa * sa, struct aaa * p2a) {
    long l1;
    char r_bc;	/* Original code uses BC register pair */

    if(sa->a_c0 != 'C')
	return 0;				/* m1: */
    if(nodesize(p2a) >= 4) {			/* m2: */
    	if(((uchar)sa->a_l15.bc[3] & 0x80) != 0) {
    	    if(sub_14F3(p2a) != REG_A) goto m4;
	}
	return (int)1;				/* m3: */
m4:	return (int)0;
    }
    l1 = (unsigned)1<<(int)nodesize(p2a)*8;	/* m5: */
    if(sub_14F3(p2a) != REG_L) goto m8;
    if(((uchar)sa->a_l15.bc[3] & 0x80) != 0) return 0;
m6: r_bc = 1;
    if(sa->a_l15.l >= l1) r_bc--;
m7: return r_bc;

m8: l1 /= 2;
    if(((uchar)sa->a_l15.bc[3] & 0x80) == 0) goto m6;
    r_bc = 1;
    if(sa->a_l15.l >= 0 - l1) goto m7;
    r_bc--;
    goto m7;
}

/* End function sub_60A8 */


/*
 * File - sub_61AA.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include <ctype.h>
#include "cgen.h"

#define REG_A 1
#define REG_L 2
#define REG_F 3

/*********************************************************
 * sub_61AA OK++			Used in: sub_5CF5
 *********************************************************/
int sub_61AA(register struct bbb * sb, int p2) {

#ifdef DEBUG
    printf("\tsub_61AA(%x, %x)\n", sb, p2);
#endif

    if(rflag == 0) {
      if(isupper(p2) != 0) {
        if(sb->b_refl == 1) {
          if(1 >= (unsigned)sb->b_nelem) {
            if(sub_6589(word_B017, 9) == 0) return 0;
            if(sb->b_c13 == 5) sb->b_c3 |= 4;
            sb->b_c13 = 2;
            sb->b_memb = (unsigned)sub_6589(word_B017, 9); /* assigning to "int *" from "unsigned int" */
            word_B017 &= ((-1) - array_AAE8[(int)sb->b_memb]);
            return 1;
          }
        }
      }
    }
    return 0;
}

/*********************************************************
 * sub_6246 OK++	      Used in: sub_508A, sub_54B6
 *********************************************************/
int sub_6246(struct aaa * p1a, struct aaa * p2a) {

#ifdef DEBUG
    printf("\tsub_6246(%x, %x)\n", p1a, p2a);
#endif

    if(nodesize(p1a) == nodesize(p2a)) {
      if(sub_14F3(p1a) == sub_14F3(p2a)) {
        return 1;
      }
    }
    return 0;
}

/*********************************************************
 * sub_628F v1 OK++ 
 *********************************************************/
char sub_628F(struct aaa * p1a, struct aaa * p2a) {

#ifdef DEBUG
    printf("\tsub_628F(%x, %x)\n", p1a, p2a);
#endif

    return ((sub_14F3(p1a) != REG_A) ||
            (sub_14F3(p2a) != REG_A)) ? (int)0 : (int)1 ;
}

/*********************************************************
 * sub_628F v2 - OK+ 
 *********************************************************
int sub_628F(struct aaa * p1a, struct aaa * p2a) {

#ifdef DEBUG
    printf("\tsub_628F(%x, %x)\n", p1a, p2a);
#endif
	
    if(sub_14F3(p1a) != REG_A) goto m1;
    if(sub_14F3(p2a) != REG_A) goto m1;
    return 1;
m1: return 0;
}
*/

/*********************************************************
 * sub_62BE OK++			Used in: sub_54B6
 *********************************************************/
char sub_62BE(register struct aaa * sa, struct aaa * p2a) {
    long l1, l2;
    char l3;

#ifdef DEBUG
    printf("\tsub_62BE(%x, %x)\n", sa, p2a);
#endif
    l3 = nodesize(sa->a_l15.wi[0])*8;
    if(l3 >= 0x20) return 1;
    l1 = (long)1<<l3;
    l2 = 0;
    if(sub_628F(sa, sa->a_l15.wi[0]) != 0) {
      l1 /= 2;
      l2 = 0 - l1;
    }
    return ((p2a->a_l15.l < l2) ||
            (p2a->a_l15.l >= l1)) ? 0 : 1;
}

/* End of file sub_61AA.c  */




/*
 * File - sub_63B8.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_63B8 OK+				Used in: sub_1F4B
 *
 * Location code snippets differs, but the program is
 * logically correct
 *********************************************************/
char sub_63B8(int p1, int p2, int p3) {
    uchar            l1;
    uchar            l0;
    int              l2;
    register uchar * st;

#ifdef DEBUG
    printf("\tsub_63B8(%x, %x, %x)\n", p1, p2, p3);
#endif

    p3 &= ~(0x40);	/* Clear bit 6 */
    l1 = 0;

    if(p2 == 0) {
      l1 = sub_6589(p1, p3);
    } else
    if((p2 & 0x8000) != 0) {				/* m2:  */
      l1 = sub_6589((((p2 & 0x8000) != 0) ?
      ((-1) - p2) : array_AAE8[p2]) & p1, p3);
    } else
    if(p3 < 24) {					/* m5:  */
      if((l1 = sub_6589(((p2 & 0x8000) ?
      ((-1) - p2) : array_AAE8[p2]) & p1, p3)) == 0) {
        if((l2 = sub_6589(p1, p3)) != 0) {
          if((char)sub_6589((l2 & 0x8000) ?
          ((-1) - l2) : array_AAE8[l2], p2) != 0) { 	/* m9:  */
            l1 = l2;					/* m10: */
          }
        }
      }
    } else {
      l2 = 6;						/* m11: */
      st = &array_AB54[((-24) + p3) * 6];
m12:  if((*(st+0) != 0) && (l2-- != 0)) {
        if((l0 = sub_6589(p1, *(st++))) == 0) goto m12;
        if(sub_6589(array_AAE8[l0], p2) == 0) {
          if(sub_6589(array_AAE8[p2], l0) == 0) goto m12;
        }
       l1 = l0;
      }
    }
    return l1;						/* m16: */
}

/* End of file sub_63B8.c  */


/*
 * File - sub_6589.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include <ctype.h>
#include "cgen.h"

extern FILE   *f_inp;
extern FILE   *f_out;

/*********************************************************
 * sub_6589 OK++    Used in: sub_1F4B, sub_2B79, sub_61AA,
 *			     sub_63B8, sub_66BC
 *********************************************************/
uchar sub_6589(int p1, int p2) {
    char    l1;
    uchar * l2;

#ifdef DEBUG
    printf("\tsub_6589(%d, %d)\n", p1, p2);
#endif

    p2 &= ~(0x40);	/* Clear bit 6 */
    if(p2 < 24) {
      if((p1 & array_AAE8[p2]) == array_AAE8[p2]) return p2;
      return 0;
    }
    p2 += (-24);		/* m1: */
    l1 = 6;
    l2 = &array_AB54[p2*6];
    do {
      if(*l2 != 0) {		/* m2: */
        if((p1 & array_AAE8[*l2]) ==  array_AAE8[*l2]) return *l2;
      }
      if(*(++l2) == 0) break;	/* m4: */
      l1 = l1 + (-1);
    } while (l1 != 0);
    return 0;			/* m5: */
}

/*********************************************************
 * sub_665B OK++			Used in: sub_66BC
 *********************************************************/
unsigned sub_665B(unsigned int p1, char p2) {
    unsigned loc;

#ifdef DEBUG
    printf("\tsub_665B(%u, %d)\n", p1, p2);
#endif
	
    if(p1 == 0) return 0;
    p2 += -48;
    loc = 1;
    while(loc < 24) {
      if((uchar)array_AB24[loc*2 + p2] == p1) return loc;
      loc++;
    }
    return 0;
}

/*********************************************************
 * sub_66BC v1 OK+			Used in: sub_1F4B
 * 
 * This function generates code as close as possible to
 * binary image.
 * Initialization variable "l2" is not required, since in
 * subsequent it is always assigned some values.
 *********************************************************/
/*
int sub_66BC(int p1, int p2, int p3, char * p4) {
    int     l1, l2; 
    char  * l3;

#ifdef DEBUG
    printf("\tsub_66BC(%x, %x, %x, %x)\n", p1, p2, p3, p4);
#endif

    l2 = 0;
    if((p2 & 0x8000) !=  0) {
      if(p1 == 0) {
        l2 = p2;
m2:     goto m25;
      }
m5:   l1 = sub_6589(((p2 & 0x8000) ? ((-1) - p2) : array_AAE8[p2])& p3, p1);
      if(l1 != 0) {
        l2 = l1;
        goto m2;
      }
m6:   l2 = sub_6589(p3, p1);
      goto m2;
    }
m7: if(p1 == 0) {
      if((p2 == 0) || (p4 == 0)) {
m9:     l2 = p2;
        goto m2;
      }
m10:  for(l3 = p4; isdigit(*(l3+1)) == 0; l3++) ;
      if(p2 >= 0x18) {
        p2 = sub_6589(p3, p2);
        if(p2 == 0) {
          l2 = p2;
          goto m2;
        }
      }
m13:  do { p2 = sub_665B(p2, (uchar)*l3); } while((l3--) != p4);
      goto m9;
    }
m14:if(p2 == 0) {
m15:  l2 = p1;
      goto m2;
    }
m16:l1=((p1 & 0x8000) ? ((-1) - p1) : array_AAE8[p1]) &	
       ((p2 & 0x8000) ? ((-1) - p2) : array_AAE8[p2]);
    if(((p1 & 0x8000) ? ((-1) - p1) : array_AAE8[p1]) == l1) goto m15;
    if(((p2 & 0x8000) ? ((-1) - p2) : array_AAE8[p2]) == l1) goto m9;
    l2 = sub_6589(l1, p1);
m25:return l2;
}
*/

/*********************************************************
 * sub_66BC v2 - OK+ Optimized version  Used in: sub_1F4B
 *
 * Excluded local variable l2, which was assigned return 
 * values.
 *********************************************************/

int sub_66BC(int p1, int p2, int p3, char * p4) {
    int     l1; 
    char  * l3;

#ifdef DEBUG
    printf("\tsub_66BC(%x, %x, %x, %x)\n", p1, p2, p3, p4);
#endif

    if((p2 & 0x8000) !=  0) {
      if(p1 == 0) return p2;
      l1 = sub_6589(((p2 & 0x8000) ?			/* m5:  */
      ((-1) - p2) : array_AAE8[p2])& p3, p1);
      if(l1 != 0) return l1;
      return sub_6589(p3, p1);				/* m6:  */
    }
    if(p1 == 0) {					/* m7:  */
      if((p2 == 0) || (p4 == 0)) return p2;
      for(l3 = p4; isdigit(*(l3+1)) == 0; l3++) ;	/* m10: */
      if(p2 >= 0x18) {
        p2 = sub_6589(p3, p2);
        if(p2 == 0) return p2;
      }
      do {
        p2 = sub_665B(p2, (uchar)*l3);			/* m13: */
      } while((l3--) != p4);
      return p2;
    }
    if(p2 == 0) return p1;				/* m14: */
    l1=((p1 & 0x8000) ? ((-1) - p1) : array_AAE8[p1]) &	/* m16: */
       ((p2 & 0x8000) ? ((-1) - p2) : array_AAE8[p2]);
    if(((p1 & 0x8000) ? ((-1) - p1) : array_AAE8[p1]) == l1) return p1;
    if(((p2 & 0x8000) ? ((-1) - p2) : array_AAE8[p2]) == l1) return p2;
    return sub_6589(l1, p1);
}

/*********************************************************
 * main OK+
 *
 * Functions of opening and closing a file are replaced by
 * standard functions
 *********************************************************/
int main(int argc, char ** argv) {

#ifdef DEBUG
    printf("\tmain()\n");
#endif

    beg_sbrk = sbrk(0);	/* Current highest memory */
    argc--;
    argv++;
    while(argc > 0 && **argv == '-') { 	/* Parsing options */
      switch(argv[0][1]) {
        case 'B': bflag = 1;	break;	/* Not use */
        case 'E': eflag = 1;	break;	/* Not use */
        case 'H': hflag = 1;	break;	/* Not use */
        case 'P':
        case 'p': pflag = 1;	break;	/* Not use */
        case 'R': rflag = 1;	break;
        case 'W':
        case 'w': wflag = 1;	break;	/* Displaying warnings */
        default:
          faterror("Illegal\tswitch %c", argv[0][1]);
          break;
      }
      argv++;
      argc--;
    }
    if(argc-- > 0) {
        if((f_inp = freopen(*argv, "r", stdin)) == 0) {		/* Open input file */
          faterror("Can't open %s", *argv);
        }
      else if(argc > 0) {
        if((f_out = freopen(argv[1], "w", stdout)) == 0) {	/* Open output file */
          faterror("Can't create %s", argv[1]);
        }
      }
    }
    sub_1680();	/* First_init */
    sub_6D1();	/* Compiling intermediate code */
    if(fclose(f_out) != 0) {					/* Close output file */
      uerror("Error closing output file");
    }
    /* Exit with error code */
    exit((errcnt ? 1 : 0));	/* Generated code is not significantly different */

}   /* End main */


/* End of file sub_6589.c  */


/*
 * File - sub_6AA2.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "cgen.h"

/* 
 * To comply with C standard functions are replaced with similar
 * ones with a variable number of parameters
 *
 * sub_6B55 excluded because it is unnecessary
 */

/*********************************************************
 * faterror OK++     Used in: sub_6C8,  sub_17E0, sub_19C1,
 *			      sub_2BD0, sub_4192, sub_6B1D,
 * Fatal error  	      sub_6B9B,
 *********************************************************/
void faterror(char * fmt, ...) {
    va_list args;

#ifdef DEBUG
    printf("\tfaterror()\n");
#endif

    fprintf(stderr, "%s:%d:\t", progname, lineno);
    if(strlen(fmt) > 0) {
      va_start(args, fmt);
      vfprintf(stderr, fmt, args);
      va_end(args);
    }
    fputc ('\n', stderr);
    fclose(f_out);	/* sub_7855(stdout); */
    exit(2);
}

/*********************************************************
 * warning v1 OK++   Used in: sub_E43,  sub_3DC9, sub_43EF,
 * Warning message	      sub_54B6, sub_5CF5, sub_600E
 *********************************************************/
void warning(char *fmt, ...) {
    va_list args;

#ifdef DEBUG
    printf("\twarning()\n");
#endif

    if(wflag == 0) {
      fprintf(stderr, "%s:%d:\t", progname, lineno);
      if(strlen(fmt) > 0) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
      }
      fprintf(stderr, " (warning)\n");
    }
}

/*********************************************************
 * faterror v0 OK++  Used in: sub_6C8,  sub_17E0, sub_19C1,
 *			      sub_2BD0, sub_4192, sub_6B1D,
 *			      sub_6B9B,
 * Fatal error      main (contains more than 1 parameter!)
 *********************************************************
void faterror(char * p1, char *p2, char *p3) {

    sub_6B55(p1, p2, p3);
    fclose(f_out);	 //sub_7855(stdout);   
    exit(2);
}
*/

/*********************************************************
 * warning v0 OK++   Used in: sub_E43,  sub_3DC9, sub_43EF,
 * Warning message	      sub_54B6, sub_5CF5, sub_600E
 *********************************************************
void warning(char *p1, char *p2, char *p3) {

    if(wflag == 0) {
      fprintf(stderr, "%s:%d:\t", progname, lineno);
      fprintf(stderr, p1, p2, p3);
      fprintf(stderr, " (warning)\n");
    }
}
*/

/* End of file sub_6AA2.c */


/*
 * File - sub_6B1D.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * uerror v1 OK++
 * Nonfatal error
 *********************************************************/
void uerror(char * msg) {

#ifdef DEBUG
    printf("\tuerror()\n");
#endif

    fprintf(stderr, msg);
    if(++errcnt >= MAXERR)
      faterror("Too many errors");
}

/*
 * Following restored functions are left as comments to
 * preserve original structure of original program.
 */

/*********************************************************
 * uerror v0 OK++		Restored by decompilation
 * Nonfatal error
 *********************************************************
void uerror(char * p1, char * p2, char * p3) {

    sub_6B55(p1, p2, p3);
    if(++errcnt >= MAXERR) {
      faterror("Too many errors");
    }
}
*/

/*********************************************************
 * sub_6B55 OK++	      	  Used in: ferror, uerror
 *
 * When changing diagnostic functions to balance number
 * parameters, this function was not required.
 *********************************************************
void sub_6B55(char *p1, char *p2, char *p3) {

    fprintf(stderr, "%s:%d:\t", progname, lineno);
    fprintf(stderr, p1, p2, p3);
    fputc ('\n', stderr);
}
*/

/* End of file sub_6B1D.c  */


/*
 * File - sub_6B9B.c Created 09.03.2019 Last Modified 30.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * allocmem OK++    Used in: sub_265,  sub_1754, sub_19C1,
 *			     sub_1B0C, sub_3712, sub_39CA,
 * alloc_mem & return ptr    sub_4192, sub_508A, sub_5DF6
 *********************************************************/
void * allocmem(unsigned int size) {
    register char * ptr;

#ifdef DEBUG
    printf("\tallocmem(%u)\n", size);
#endif

    do {
      if((ptr = cmalloc(size)) != (void *)0) goto m1;
    } while (sub_374C() != 0);
    faterror("No room");
m1: blkclr(ptr, size);
    return ptr;
}	

/* End of file sub_6B9B.c  */


/*
 * File - sub_6D1C.c Created 09.03.2019 Last Modified 26.05.2020
 */

#include "stdio.h"
#include "cgen.h"

/*********************************************************
 * sub_6D1C v2 OK++	      Used in: sub_6D61, cmalloc
 *********************************************************/
void * sub_6D1C(register char * p1, int p2) {

#ifdef DEBUG
    printf("\tsub_6D1C(%x, %x)", p1, p2);
#endif

    if(0x80 < p2) {
      *((int *)p1) = p2-3;
      p1 += 3;
      *((char *)p1-1) = 0x80;	/* bug in compiler v3.09 */
    } else {
      *(char *)p1 = (char)p2-1;
      p1++;
    }
#ifdef DEBUG
    printf("\tReturn %x\n", p1);
#endif
    return p1;
}

/*********************************************************
 * sub_6D61 v4 OK++		 	  Used in: cmalloc
 *
 * Compiled code is not significantly different from binary
 * image	
 *********************************************************/
int sub_6D61(void) {
    struct ptr          * l1;
    struct ptr          * l2;
    struct ptr          * l3;
    struct ptr          * l4;
    char                  l5;	/* Senseless variable */
    register struct ptr * st;

#ifdef DEBUG
    printf("\tsub_6D61()\n");
#endif

    l5 = 0;
m1: l4 = &word_B023.next;
    while((st = l4->next_ptr) != 0) {				/* m17: */
      l2 = st;							/* m2:  */
      if(bittst(*((char*)st-1),7) != 0)
        l2 = (struct ptr *)((int)l2 - 3); 			/* m3:  */	/* cast to "struct ptr *" from smaller integer type "int" */
      else
        l2 = (struct ptr *)((int)l2 - 1); 
      l3 = &word_B023.next;					/* m4:  */	/* cast to "struct ptr *" from smaller integer type "int" */
      while((l1 = l3->next_ptr) != 0) {				/* m16: */  
        if(((bittst((unsigned)((uchar)*((char*)l1-1)),7) ?	/* m5:  */
        (unsigned)*((int *)((char *)l1-3)) :			/* m6:  */
        (uchar)*((char *)((char *)l1-1))) + (int)l1) == l2) {	/* m7:  */	/* comparison "unsigned int" and "struct ptr *" */
          if(l3 == st) {					/* m17: */
            l4->next_ptr = l1->next_ptr;
          } else {
            if(l4 == l1) {					/* m8:  */
              l3->next_ptr = st->next_ptr;
            } else {
              l3->next_ptr = l1->next_ptr;			/* m9:  */
              l4->next_ptr = st->next_ptr;
            }
          }
          if((bittst((char)(container_of(l1, struct header1, next))->size,7)) != 0 ) /* m10 */
            l1 = (struct ptr *)((int)l1 - 3);
          else
            l1 = (struct ptr *)((int)l1 - 1); 			/* m11: */
          sub_7028((void *)sub_6D1C((char *)l1, (0-(int)l1) +	/* m14: */
          ((bittst(*((uchar*)st-1),7)) != 0 ? 			/* m12: */
          *((int *)((char *)st-3)) :				/* m13: */
          *((uchar *)st-1)) + (int)st));
          l5 = 1;
          goto m1;
        }
        l3 = l1;						/* m15: */
      }
#ifdef DEBUG
      printf("\tsub_6D61\t\tReturn %x\n", st);
#endif
      l4 = st;
    }
}

/*********************************************************
 * cmalloc v2 OK++			Used in: allocmem
 *********************************************************/
void * cmalloc(unsigned p1) {
    char	  * l1;	
    unsigned 	    l2;	
    uchar	    l3;
    register char * sst;

#ifdef DEBUG
    printf("\tcmalloc(%u)\n", p1);
#endif

    if(p1 < 2) p1 = 2;
    l3 = 0;
    do {
      sst = (char *)&word_B023+1;
      while((l1 = (char *)(*((int *)sst))) != 0) {	/* cast to "char *" from smaller integer type "int" */
	if((bittst((unsigned)((uchar)*((char*)l1-1)),7) ?
	(unsigned)*((int *)((char *)l1-3)) :
	(uchar)*((char *)((char *)l1-1))) >= p1) {
	  *((int *)sst) = *((int *)l1);			/* sst->ptr = l1->ptr */
	  sst = l1;
	  if(p1+6 < (l2 = (bittst(*((uchar*)sst-1),7) != 0) ?
	  (unsigned)*((int *)((uchar*)sst-3)) : *((uchar*)sst-1))) {
	    l1 = p1 + sst;
	    sub_7028((void *)sub_6D1C(l1, l2-p1));
	    if(bittst(*((char*)sst-1),7) != 0)
	      sst += -3;
	    else
	      sst += -1;
	    return (void *)sub_6D1C(sst, p1);
	  }
	  return sst;
	}
	sst = l1;
      }
      if(((char)l3) != 0) break;
    } while ((l3 = sub_6D61()) != 0);

    l2 = ((p1 < 0x80)) ? (unsigned)1 : (unsigned)3;
    if((sst = sbrk(p1+l2)) == ((char *) -1)) return 0;
    return (void *)sub_6D1C(sst, p1+l2);
}

/*********************************************************
 * sub_7028 v6 OK++  Used in: sub_406,  sub_36E0, sub_374C
 *			      sub_5DF6, sub_6D61, cmalloc
 *
 * Function consisting only of macros generates code exactly
 * corresponding to original and does not generate any
 * diagnostic messages when compiled. Algorithm used to
 * allocate and manage memory by an ordinary person is
 * perceived with great difficulty.
 *********************************************************/
void sub_7028(struct ptr * p1) {
    register struct ptr * st;

#ifdef DEBUG
    printf("\tsub_7028(%x)\n", p1);
#endif

    st = &word_B023.next;
    while((st->next_ptr != 0) && 	/* m2: */
    (((bittst((container_of(st->next_ptr, struct header1, next))->size,7)) ?
    ((container_of(st->next_ptr, struct header2, next))->size) :
    ((container_of(st->next_ptr, struct header1, next))->size)
    ) < 
    ((bittst((container_of(p1, struct header1, next))->size,7)) ?
    ((container_of(p1, struct header2, next))->size) :
    ((container_of(p1, struct header1, next))->size)))) {
      st = st->next_ptr;		/* m1: */
    }
    p1->next_ptr = st->next_ptr;	/* m7: */
    st->next_ptr = p1;
}

/* End of file sub_6D1C.c  */


